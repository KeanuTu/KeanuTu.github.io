<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在线商城项目]]></title>
    <url>%2F2019%2F12%2F28%2F%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[引言Servlet+JSP+JavaBean+MySQL的在线商城项目 在线商城系统，是一个基于 Java 为后台的 B/S 系统。包括前台购买功能和后台管理功能。游客可以浏览商品，普通顾客可以进入前台购买界面购买商品，系统管理人员可以进入后台管理界面进行管理操作。 在前台购买界面，首先会按分类显示商品信息，包括商品的名称、品牌、图片以及价格等基本信息。游客只能浏览商品信息，只有登录系统成为普通用户才可购买商品。游客通过输入用户名和密码登录系统成为普通用户。普通用户可以选择将商品加入购物车，可以返回继续添加商品。选择完要购买的商品后，进入购物车界面点击购买按钮，系统会将购物车内的商品以及用户信息生成一个订单，普通用户还可以进入订单界面查看订单是否发货。 在后台管理页面，系统管理员可以分别对分类、商品和用户订单进行管理。其中分类管理包含添加分类以及查看分类，管理员通过填写分类名称和分类描述创建新分类。商品管理包含添加商品以及查看商品，管理员通过填写商品名称、品牌、售价、商品描述以及上传图片和选择分类创建新商品。订单管理包括查看未发货订单、查看已发货订单和确认发货。未发货订单被确认发货后，会变成已发货订单 0、知识概要Servlet: 主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。 JSP: 一种动态页面技术，它的主要目的是将表示逻辑从 Servlet 中分离出来 。 JSTL: 是一个 JSP 标签集合，它封装了 JSP 应用的通用核心功能 详情可以下载：J2EE知识点总结 通过登录&amp;注册模块设计理解JSP+Servlet+MySQL相互协同工作1、项目结构 MVC(Model-View-Controller) 设计模式： Model对象：负责存储数据以及定义如何操作这些数据。 View对象：负责展示而且允许用户编辑来自应用程序的Model对象，View对象用来构建用户界面，与用户交互。 Controller对象：是Model对象与View对象的中间人，负责传递数据，监听各种事件，管理其他对象的生命周期等。 bean层主要负责实体，一般是数据库表的实体并设置geter/seter方法。 dao层主要负责定义每个数据表的具体操作函数，例如增删改查子类。 servlet层主要负责页面交互控制，比如用户点击登录，通过web.xml定义的映射关系，定位到LoginServlet进行处理，而Loginservlet内部调用dao层的查找函数对数据库进行查询，验证登录是否成功，若成功页面跳转至首页，若不成功页面提示用户输入不正确，返回重新登录。 utils层主要负责定义一些工具类，比如数据连接工具类DBUtils,其中通过解析db.properties数据配置文件的类方法getConnection()获取一个数据连接。 前面这些相当于Controller和Model层，而webContent目录下的.jsp文件则主要用于页面展示，即View层。 2、项目模块具体代码bean层： 1234567891011121314151617181920212223242526/** * @Title: Users.java * @Package bean * @Description: 登录的用户类* @author Keanu */package bean;public class Users &#123; private String name; private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; dao层： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package dao;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import com.mysql.jdbc.PreparedStatement;import bean.Users;import utils.DBUtil;public class UserDao &#123;private static Connection connection = DBUtil.getConnection(); //插入 public boolean insertNewUser(Users user) &#123; String sql ="insert into tb_user(name,password) values(?,?)"; try(PreparedStatement preparedStatement =(PreparedStatement) connection.prepareStatement(sql)) &#123; preparedStatement.setString(1, user.getName()); preparedStatement.setString(2, user.getPassword()); return preparedStatement.executeUpdate()&gt;0; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; return false; &#125; //查询所有 public List&lt;Users&gt; selectAllUser()&#123; String sql ="select name,password from tb_user"; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); try (PreparedStatement preparedStatement = (PreparedStatement) connection.prepareStatement(sql);ResultSet resultSet = (ResultSet) preparedStatement.executeQuery()) &#123; while (resultSet.next()) &#123; Users user = new Users(); user.setName(resultSet.getString("name")); user.setPassword(resultSet.getString("password")); list.add(user); &#125; return list; &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; return null; &#125; //更改 public boolean updateUserByName(Users user) &#123; String sql = "UPDATE tb_user SET password=? where name=?"; try &#123; PreparedStatement preparedStatement = (PreparedStatement) connection.prepareStatement(sql); preparedStatement.setString(1, user.getPassword()); preparedStatement.setString(2, user.getName()); return preparedStatement.executeUpdate()&gt;0; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return false; &#125; //删除 public boolean deleteUserByName(String name) &#123; String sql = "DELETE FROM tb_user where name=?"; try &#123; PreparedStatement preparedStatement = (PreparedStatement) connection.prepareStatement(sql); preparedStatement.setString(1,name); return preparedStatement.executeUpdate()&gt;0; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; return false; &#125;&#125; //查询是否存在单个对象public boolean check(String username,String password) &#123; String sql = "SELECT count(*) FROM user WHERE username=? and password=?"; try &#123; ps = connection.prepareStatement(sql); ps.setString(1, username); ps.setString(2, password); rs = ps.executeQuery(); if(rs.next()) &#123; int count = rs.getInt(1); if(count == 1)&#123; return true; &#125; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return false; &#125; servlet层： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package servlet;import java.io.IOException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import bean.Users;import dao.UserDao;import utils.DBUtil;/** * Servlet implementation class LoginServlet */public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public LoginServlet() &#123; super(); &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取request对象参数 String username = request.getParameter("username"); String password = request.getParameter("password"); //获取session对象 HttpSession session = request.getSession(); UserDao dao = new UserDao(); if(dao.check(username,password)) &#123; System.out.println("用户名和密码正确"); Users user= new Users(); user.setName(username); user.setPassword(password); //将用户名保存再session对象中 session.setAttribute("user", user); response.sendRedirect(request.getContextPath()+"/listProduct"); &#125;else &#123; //客户端跳转 response.sendRedirect("login.jsp"); System.out.println("用户名和密码错误"); &#125; &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125; login.jsp(采用BootStrap框架使得页面样式美化) 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;登录页&lt;/title&gt; &lt;script src="static/js/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="static/css/bootstrap/3.3.6/bootstrap.min.css"&gt; &lt;script src="static/js/bootstrap/3.3.6/bootstrap.min.js"&gt;&lt;/script&gt; &lt;link rel="shortcut icon" href="static/mistletoe.ico"&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="login" method="post"&gt; &lt;table class="table table-bordered" style="width:500px;margin:10px auto;"&gt; &lt;thead&gt; &lt;th colspan="2" style="text-align:center;" &gt;欢迎登录&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style="text-align:center"&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type="text" class="from-control" name="username" value=""&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="text-align:center"&gt;密&amp;nbsp;码：&lt;/td&gt; &lt;td&gt;&lt;input type="password" class="from-control" name="password" value=""&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" style="text-align:center"&gt;&lt;button type="submit"&gt;登录&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" style="text-align:center"&gt;&lt;p&gt;还没有账号？&lt;a href="registe.jsp"&gt;立即注册&lt;/a&gt;&lt;/p&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; web.xml 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;servlet&gt; &lt;description&gt;登录处理&lt;/description&gt; &lt;display-name&gt;LoginServlet&lt;/display-name&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 3、项目具体效果跟上面没有太大关系，但是原理相同 前台首页 购物车页 订单页 订单详情页 后台管理员]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap]]></title>
    <url>%2F2019%2F12%2F11%2FBootStrap%2F</url>
    <content type="text"><![CDATA[BootStrap 是Twitter的工程师开发的前端框架，可以非常方便的设计出好看的页面效果。]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端框架]]></title>
    <url>%2F2019%2F12%2F04%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[JSON、Ajax和Jquery相关知识总结； 1、JSONJavaScript对象表示方法（ JavaScript Object Notation ）是一种存储数据的方式。 JSON对象由 名称/值对组成 名称和值之间用冒号:隔开，名称必须用双引号” 包含起来值可以是任意Javascript数据类型，字符串，布尔，数字 ，数组甚至是对象不同的名称/值对之间用 逗号 , 隔开 12345678&lt;script&gt; var stu = [ //创建JSON对象 &#123;"name":"张三", "age":"12"&#125;, &#123;"name":"李四", "age":"12"&#125;, &#123;"name":"王五", "age":"12"&#125; ] stu[2].name; //访问JSON数组对象-&gt;王五&lt;/script&gt; JSON格式字符串转为JSON对象：eval(&quot;(&quot;+str+&quot;)&quot;); JSON对象转换为字符串：JSON.stringify(JsonObj); 2、AJAX 通过AJAX (Asynchronous JavaScript And XML) 实现异步刷新 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX使用步骤： 1）创建对象 var xhr = new XMLHttpRequest() 2）配置对象 xhr.open( 参数一，参数二 , 参数三 ) ​ a、参数一：请求方式（GET|POST） ​ b、参数二：地址（url 文件在服务器上的位置 ） ​ c、参数三：是否为异步（true|false）—–默认为true 3）发送请求 xhr.send( ) 4）监听请求回调 ​ 事件 : ​ (1)xhr.onreadystatechange = function( ){ } ​ (2)xhr.onload = function( ){ } ​ (3)xhr.onprogress = function( ){ } 5) 处理响应消息 ​ 服务器响应字符串和XML形式的–&gt;responseText/responseXML 注：onreadystatechange事件 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status 200: “OK” 404: 未找到页面 AJAX实例： 123456789101112131415161718function getInfo()&#123; var xmlhttp; if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123; var str = xmlhttp.responseText; alert(str); &#125; &#125; xmlhttp.open("GET","/url",true); xmlhttp.send();&#125; ajax的目标：无刷新加载页面 ​ 1）发送请求 ​ 2）服务器返回内容有两种： ​ （a）html页面 ​ （b）数据（在页面内发送的请求服务器当场返回的是数据）（ json ） 在浏览器地址栏输入url按下Enter键后会发生什么？（面试题） 1）域名解析 —–把域名解析成ip地址 （DNS域名解析系统） ​ 2）把ip地址发送到网络供应端，去找相对应的主机服务器 ​ 3）TCP的三次握手，简历连接 ​ 4）开始发送请求，取回入口文件 ​ 5）开始解析入口文件，并取回需要的资源 ​ 6）进行后续操作 3、JQuery JQuery是一个Javascript的框架，是对Javascript的一种封装。 详细知识参考链接：[JQuery笔记详细版]: https://blog.csdn.net/qq_37957971/article/details/82812002 使用JQuery需要导入一个第三方 Javascript库 jquery.min.js (点击下载) 以下是jQuery的相关信息： 官网：http://jquery.com/ 官网API文档：http://api.jquery.com/ 中文汉化API文档：http://www.css88.com/jqapi-1.9/ JQuery的两大特点： （1）链式编程：比如.show()和.html()可以连写成.show().html()。 （2）隐式迭代：隐式 对应的是 显式。隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。 使用JQuery的步骤： 入口函数（重点）原生JS的入口函数指的是:window.onload = function(){};如下： 12345 //原生 js 的入口函数。页面上所有内容加载完毕，才执行。 //不仅要等文本加载完毕，而且要等图片也要加载完毕，才执行函数。window.onload = function () &#123; alert(1);&#125; JQuery的入口函数，写法： 写法一： 1234//1.文档加载完毕，图片不加载的时候，就可以执行这个函数。 $(document).ready(function () &#123; alert(1); &#125;) 写法二：（写法一的简洁版） 1234//2.文档加载完毕，图片不加载的时候，就可以执行这个函数。$(function () &#123; alert(1);&#125;); 写法三： 1234//3.文档加载完毕，图片也加载完毕的时候，在执行这个函数。$(window).ready(function () &#123; alert(1);&#125;) 注：$ == JQuery，$表示函数 js中的DOM对象 和 jQuery对象 比较（重点，难点）二者的区别通过 jQuery 获取的元素是一个数组，数组中包含着原生JS中的DOM对象。举例： 针对下面这样一个div结构： 12345&lt;div&gt;&lt;/div&gt;&lt;div class="box"&gt;&lt;/div&gt;&lt;div id="box"&gt;&lt;/div&gt;&lt;div class="box"&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 通过原生 js 获取这些元素节点的方式是： 123var myBox = document.getElementById("box"); //通过 id 获取单个元素var boxArr = document.getElementsByClassName("box"); //通过 class 获取的是数组var divArr = document.getElementsByTagName("div"); //通过标签获取的是数组 通过 jQuery 获取这些元素节点的方式是：（获取的都是数组） 1234//获取的是数组，里面包含着原生 JS 中的DOM对象。var jqBox1 = $("#box");var jqBox2 = $(".box");var jqBox3 = $("div"); 两者互相转换： 1、DOM对象转为JQuery对象 1$(JS对象) 2、JQuery对象转为DOM对象 12JQuery对象[index]; //方法一，推荐JQuery对象.get(index);//方法二 +++ JQuery选择器1、JQuery基本选择器 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;基本选择器&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; //入口函数 $(document).ready(function()&#123; //以三种方式获取jquery对象 var jqBox1 = $("#box"); var jqBox2 = $(".box"); var jqBox3 = $("div") //操作标签选择器 jqBox3.css("width",100); jqBox3.css("height",100); jqBox3.css("backgroundColor","pink"); //操作类选择器(隐式迭代，不用一个一个设置) jqBox2.css("background", "red"); //操作id选择器 jqBox1.css("background", "yellow"); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div id="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、层级选择器 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery-1.11.1.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //获取ul中的li设置为粉色 //后代：儿孙重孙曾孙玄孙.... var jqLi = $("ul li"); jqLi.css("margin", 5); jqLi.css("background", "pink"); //子代：亲儿子 var jqOtherLi = $("ul&gt;li"); jqOtherLi.css("background", "red"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;ol&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;/ol&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 3、基本过滤器 1234567891011121314151617181920212223242526&lt;script src="jquery-1.11.1.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function () &#123; // :odd $("li:odd").css("background", "red"); // :even $("li:even").css("background", "green"); // :eq(index) $("ul li:eq(3)").css("font-size", "30px"); //设置第四个li的字体 // :lt(index) $("li:lt(6)").css("font-size", "30px"); // :gt(index) $(".ulList1 li:gt(7)").css("font-size", "40px"); // :first $(".ulList li:first").css("font-size", "40px"); // :last $("li:last").css("font-size", "40px"); &#125;); &lt;/script&gt; 4、属性选择器 5、筛选选择器 实例一：鼠标悬停时，弹出下拉菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; .wrap &#123; width: 330px; height: 30px; margin: 100px auto 0; padding-left: 10px; background-color: pink; &#125; .wrap li &#123; background-color: lightblue; &#125; .wrap &gt; ul &gt; li &#123; float: left; margin-right: 10px; position: relative; &#125; .wrap a &#123; display: block; height: 30px; width: 100px; text-decoration: none; color: #000; line-height: 30px; text-align: center; &#125; .wrap li ul &#123; position: absolute; top: 30px; display: none; &#125; &lt;/style&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; //入口函数 $(document).ready(function () &#123; //需求：鼠标放入一级li中，让他里面的ul显示。移开隐藏。 var jqli = $(".wrap&gt;ul&gt;li"); //绑定事件 jqli.mouseenter(function () &#123; //这个位置用到了this. // console.log(this); //打印结果是js中的dom对象。注意：jquery对象绑定的事件中，this指js中的dom对象。【重要】 //让this中的ul显示出来。// 原生 js 的做法是：this.children[1].style.display = "block"; //把js的dom对象包装为jquery对象，然后用jquery方法操作 $(this).children("ul").show(); &#125;); //绑定事件：鼠标移开时，隐藏下拉菜单 jqli.mouseleave(function () &#123; $(this).children("ul").hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;ul&gt; &lt;li&gt; &lt;a href="javascript:void(0);"&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="javascript:void(0);"&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:void(0);"&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:void(0);"&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="javascript:void(0);"&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="javascript:void(0);"&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:void(0);"&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:void(0);"&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="javascript:void(0);"&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="javascript:void(0);"&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:void(0);"&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:void(0);"&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可实现两级菜单，水平式布局。 举例二：鼠标悬停时变色完整版代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求；隔行变色；鼠标悬停时，还要变色。 var jqli1 = $("li:odd"); var jqli2 = $("li:even"); jqli1.css("background", "#cccccc"); jqli2.css("background", "white"); //鼠标悬停时变色 var color = ""; $("li").mouseenter(function () &#123; color = $(this).css("background"); //先把之前的颜色保存下来，鼠标离开时还原 $(this).css("background", "green"); &#125;); //鼠标离开时，恢复为原来的颜色 $("li").mouseleave(function () &#123; $(this).css("background", color); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 举例三：突出显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; body &#123; background: #000; &#125; .wrap &#123; margin: 100px auto 0; width: 630px; height: 394px; padding: 10px 0 0 10px; background: #000; overflow: hidden; border: 1px solid #fff; &#125; .wrap li &#123; float: left; margin: 0 10px 10px 0; &#125; .wrap img &#123; display: block; border: 0; width: 200px; height: 180px; &#125; &lt;/style&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery(window).ready(function () &#123; //需求：鼠标放入li中，其他的li半透明，当前盒子的opacity值为1 $(".wrap").find("li").mouseenter(function () &#123; //链式编程 $(this).css("opacity", 1).siblings("li").css("opacity", 0.4); &#125;); //离开wrap的时候所有的li的全部opacity值为1； $(".wrap").mouseleave(function () &#123; $(this).children().children("li").css("opacity", 1);// $(".wrap li").css("opacity",1); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/01.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/02.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/03.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/04.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/05.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/06.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 举例四：手风琴效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; * &#123;padding: 0;margin: 0;&#125; ul &#123; list-style-type: none;&#125; .parentWrap &#123; width: 200px; text-align:center; &#125; .menuGroup &#123; border:1px solid #999; background-color:#e0ecff; &#125; .groupTitle &#123; display:block; height:20px; line-height:20px; font-size: 16px; border-bottom:1px solid #ccc; cursor:pointer; &#125; .menuGroup &gt; div &#123; height: 200px; background-color:#fff; display:none; &#125; &lt;/style&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求：鼠标点击span，让他下面的div显示出来。让其他的div隐藏。 $(".parentWrap span").click(function () &#123;// $(this).next().show();// //让其他的隐藏// //点击的span的父亲li，的所有的兄弟元素li，的孩子元素div全部隐藏。// $(this).parent("li").siblings("li").children("div").hide(); //连式编程 $(this).next().show().parent("li").siblings("li").find("div").hide(); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class="parentWrap"&gt; &lt;li class="menuGroup"&gt; &lt;span class="groupTitle"&gt;标题1&lt;/span&gt; &lt;div&gt;我是弹出来的div1&lt;/div&gt; &lt;/li&gt; &lt;li class="menuGroup"&gt; &lt;span class="groupTitle"&gt;标题2&lt;/span&gt; &lt;div&gt;我是弹出来的div2&lt;/div&gt; &lt;/li&gt; &lt;li class="menuGroup"&gt; &lt;span class="groupTitle"&gt;标题3&lt;/span&gt; &lt;div&gt;我是弹出来的div3&lt;/div&gt; &lt;/li&gt; &lt;li class="menuGroup"&gt; &lt;span class="groupTitle"&gt;标题4&lt;/span&gt; &lt;div&gt;我是弹出来的div4&lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; JQuery思维导图总结： xmind文件下载：点击下载 参考博文链接： https://blog.csdn.net/qq_37957971/article/details/82812002]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JQuery</tag>
        <tag>Ajax</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2019%2F12%2F04%2F%E5%89%8D%E7%AB%AF%E9%83%A8%E5%88%86-02%2F</url>
    <content type="text"><![CDATA[引言网页和用户之间的交互，网页的动态效果。 一、JavaScrip总结[TOC] 完整的JavaScript由语言基础，BOM和DOM组成。 ●ES语法：ECMAScript.主要版本ES5和ES6 ●DOM：文档对象模型（Document Object Model），是W3C组织推荐的处理可扩展标志语言的标准编程接口。 ●BOM：浏览器对象模型（Browser Object Model），提供了独立于内容的、可以与浏览器窗口进行互动的对象结构；且由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。 1、语法1.1 引用方式​ 1) 行间式：存在于行间事件中 12&lt;body id="body"onload="body.style.backgroundColor='#Off'"&gt;&lt;/body&gt; ​ 2) 内联式：存在于页面Script标签中 1234&lt;script&gt;function add (): &lt;/script&gt; ​ 3) 外联式 1&lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; 1.2 变量声明 变量名的定义 JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头。 声明变量使用 var 变量名; 的格式来进行声明 注意： 变量名是区分大小写的。 推荐使用驼峰式命名规则。 保留字不能用做变量名。 补充： ES6新增const用来声明常量。一旦声明，其值就不能改变。 ECMA6 中添加了新的关键字，可以命令局部作用域 JavaScript不区分整型和浮点型，就只有一种数字类型 。还有一种NaN，表示不是一个数字（Not a Number），NaN表示当前转换的对象不是一个数字，但是他是数值类型 1.3 字符串操作 方法 说明 .length 返回长度 .trim() 移除空白 .trimLeft() 移除左边的空白 .trimRight() 移除右边的空白 .charAt(n) 返回第n个字符 .concat(value, …) 拼接（一般用+来进行字符串） .indexOf(substring, start) 子序列位置 .substring(from, to) 根据索引获取子序列 .slice(start, end) 切片 .toLowerCase() 小写 .toUpperCase() 大写 .split(delimiter, limit) 分割 slice和substring的特点： string.slice(start, stop)和string.substring(start, stop)： 两者的相同点： 如果start等于end，返回空字符串 如果stop参数省略，则取到字符串末 如果某个参数超过string的长度，这个参数会被替换为string的长度 substirng()的特点： 如果 start &gt; stop ，start和stop将被交换 如果参数是负数或者不是数字，将会被0替换 silce()的特点： 如果 start &gt; stop 不会交换两者 如果start小于0，则切割从字符串末尾往前数的第abs(start)个的字符开始(包括该位置的字符) 如果stop小于0，则切割在从字符串末尾往前数的第abs(stop)个字符结束(不包含该位置字符) null和undefined区别： null表示值是空，一般在需要指定或清空一个变量时才会使用，如 name=null; undefined表示当声明一个变量但未初始化时，该变量的默认值是undefined。还有就是函数无明确的返回值时，返回的也是undefined。 null表示变量的值是空(null可以手动清空一个变量的值，使得该变量变为object类型，值为null)，undefined则表示只声明了变量，但还没有赋值 Number转换为字符串的时候有默认模式和基模式两种 //默认模式：十进制 str.toString(); //基模式：二进制，八进制和十六进制 str.toString(2); //8|16 1.4 数组操作 数组对象的作用是：使用单独的变量名来存储一系列的值。 方法 说明 .length 数组的大小 .push(ele) 尾部追加元素 .pop() 获取尾部的元素 .unshift(ele) 头部插入元素 .shift() 头部移除元素 .slice(start, end) 切片 .reverse() 反转 .join(seq) 将数组元素连接成字符串 .concat(val, …) 连接数组 .sort()0 排序 .forEach() 将数组的每个元素传递给回调函数 .splice() 删除元素，并向数组添加新元素。 .map() 返回一个数组元素调用函数处理后的值的新数组 1.5 查看数据类型typeof是一个一元运算符（就像++，–，！，- 等一元运算符），不是一个函数，也不是一个语句。 对变量或值调用 typeof 运算符将返回下列值之一： undefined - 如果变量是 Undefined 类型的 boolean - 如果变量是 Boolean 类型的 number - 如果变量是 Number 类型的 string - 如果变量是 String 类型的 object - 如果变量是一种引用类型或 Null 类型的 :balance_scale:字符串转换为数字：内置函数parseInt()和parseFloat()，但是只会转换字符串中数字部分，出现非数字部分终止转换。 Number()和parseInt()的区别：Number()转换包含非数字时，会返回NaN。 :gem:转换为Boolean：内置函数Boolean() 当转换字符串时： 非空即为true 当转换数字时： 非0即为true 当转换对象时： 非null即为true 1.6 内置对象和方法 JavaScript的对象（Object）本质上是键值对的集合（Hash结构），但是只能用字符串作为键。 1234567891011var a = &#123;"name": "MLXG", "age": 18&#125;;console.log(a.name);console.log(a["age"]);&gt;&gt;&gt;‘MLXG’&gt;&gt;&gt;18var a = &#123;"name": "UZI", "age": 18&#125;;for (var i in a)&#123; console.log(i, a[i]);&#125;&gt;&gt;&gt;name uzi&gt;&gt;&gt;age 18 Date对象 12345678910111213141516//方法1：不指定参数var d1 = new Date();console.log(d1.toLocaleString());//方法2：参数为日期字符串var d2 = new Date("2004/3/20 11:12");console.log(d2.toLocaleString());var d3 = new Date("04/03/20 11:12");console.log(d3.toLocaleString());//方法3：参数为毫秒数var d3 = new Date(5000);console.log(d3.toLocaleString());console.log(d3.toUTCString());//方法4：参数为年月日小时分钟秒毫秒var d4 = new Date(2004,2,20,11,12,0,300);console.log(d4.toLocaleString()); //毫秒并不直接显示 Date对象的方法 1234567891011var d = new Date(); //getDate() 获取日//getDay () 获取星期//getMonth () 获取月（0-11）//getFullYear () 获取完整年份//getYear () 获取年//getHours () 获取小时//getMinutes () 获取分钟//getSeconds () 获取秒//getMilliseconds () 获取毫秒//getTime () 返回累计毫秒数 JSON对象 123456var str1 = '&#123;"name": "Faker","age":18&#125;';var obj1 = &#123;"name": "Faker","age":18&#125;;//JSON字符串转换成对象var obj = JSON.parse(str1); //loads//对象转换成JSON字符串var str = JSON.stringify(obj1); //dumps 正则表达式 1234567891011121314151617181920212223242526272829//定义正则表达式两种方式var reg1 = new RegExp("^[a-zA-Z]&#123;5,11&#125;");var reg2 = /^[a-zA-Z]&#123;5,11&#125;$/;//正则校验数据reg1.test('tjjs13');reg2.test('thyd32');/*第一个注意事项，正则表达式中不能有空格*/ // 全局匹配var s1 = 'egondsb dsb dsb';s1.match(/s/)s1.match(/s/g)var reg2 = /^[a-zA-Z][a-zA-Z0-9]&#123;5,9&#125;$/greg2.test('egondsb');reg2.test('egondsb');reg2.lastIndex;/*第二个注意事项，全局匹配时有一个lastIndex属性*/// 校验时不传参数,默认匹配undefinedvar reg2 = /^[a-zA-Z][a-zA-Z0-9]&#123;5,9&#125;$/reg2.test();reg2.test(undefined);var reg3 = /undefined/;reg3.test();RegExp :jack_o_lantern::jack_o_lantern::jack_o_lantern: 1.7 JavaScript自定义对象1.7.1 通过new Object创建对象123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Object构造函数模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式一: Object构造函数模式 * 套路: 先创建空Object对象, 再动态添加属性/方法 * 适用场景: 起始时不确定对象内部数据 * 问题: 语句太多--&gt;&lt;script type="text/javascript"&gt; /* 一个人: name:"Tom", age: 12 */ // 先创建空Object对象 var p = new Object() p = &#123;&#125; //此时内部数据是不确定的 // 再动态添加属性/方法 p.name = 'Tom' p.age = 12 p.setName = function (name) &#123; this.name = name &#125; //测试 console.log(p.name, p.age) p.setName('Bob') console.log(p.name, p.age)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.7.2 工厂模式：通过function设计一个对象1234567891011121314151617181920212223242526272829303132333435363738&lt;!--方式三: 工厂模式 * 套路: 通过工厂函数动态创建对象并返回 * 适用场景: 需要创建多个对象 * 问题: 对象没有一个具体的类型, 都是Object类型--&gt;&lt;script type="text/javascript"&gt; function createPerson(name, age) &#123; //返回一个对象的函数===&gt;工厂函数 var obj = &#123; name: name, age: age, setName: function (name) &#123; this.name = name &#125; &#125; return obj &#125; // 创建2个人 var p1 = createPerson('Tom', 12) var p2 = createPerson('Bob', 13) // p1/p2是Object类型 function createStudent(name, price) &#123; var obj = &#123; name: name, price: price &#125; return obj &#125; var s = createStudent('张三', 12000) // s也是Object&lt;/script&gt; 1.7.3 为已存在的对象，增加新的方法1234567891011121314&lt;!--方式三: 自定义构造函数模式 * 套路: 自定义构造函数, 通过new创建对象 * 适用场景: 需要创建多个类型确定的对象 * 问题: 每个对象都有相同的数据, 浪费内存--&gt;&lt;script&gt;createPerson.prototype.newP = function()&#123; document.write(this.name + "改写后的方法");&#125;//第二种形式&lt;/script&gt; 1.7.4 对象字面量1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;对象字面量&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式四: 对象字面量模式 * 套路: 使用&#123;&#125;创建对象, 同时指定属性/方法 * 适用场景: 起始时对象内部数据是确定的 * 问题: 如果创建多个对象, 有重复代码--&gt;&lt;script type="text/javascript"&gt; var p = &#123; name: 'Tom', age: 12, setName: function (name) &#123; this.name = name &#125; &#125; //测试 console.log(p.name, p.age) p.setName('JACK') console.log(p.name, p.age) var p2 = &#123; //如果创建多个对象代码很重复 name: 'Bob', age: 13, setName: function (name) &#123; this.name = name &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、BOMBOM即浏览器对象模型（Browser Object Model） 浏览器对象包括： 2.1 Window(窗口) 所有浏览器都支持 window 对象。它表示浏览器窗口。 如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 全局变量是 window 对象的属性。全局函数是window对象的方法 window.innerHeight - 浏览器窗口的内部高度 window.innerWidth - 浏览器窗口的内部宽度 window.open() - 打开新窗口 window.close() - 关闭当前窗口 2.2 Navigator(浏览器) 浏览器对象，通过这个对象可以判定用户所使用的浏览器，包含了浏览器相关信息。 navigator.appName // Web浏览器全称 navigator.appVersion // Web浏览器厂商和版本的详细字符串 navigator.userAgent // 客户端绝大部分信息 navigator.platform // 浏览器运行所在的操作 2.3 Screen(客户端屏幕) screen对象表示用户的屏幕相关信息 screen.width; //用户的屏幕分辨率 screen.availWidth; //可用区域大小 2.4 History(访问历史) history用于记录访问历史 history.forward() // 前进一页 history.back() // 后退一页 history.go(-2) //上上一页 2.5 Location(浏览器地址) window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。 location.href 获取URL location.href=”URL” // 跳转到指定页面 location.reload() 重新加载页面 :seat::seat::seat::seat::seat: 2.6 弹出框 浏览器上常见的弹出框有警告框，确认框，提示框 这些都是通过调用window的方法实现的。 关键字 简介 用法 alert 警告框 常用于消息提示，比如注册成功等等 confirm 确认框 常用于危险性操作的确认提示。 比如删除一条记录的时候，弹出确认框 2.7 计时器 关键字 简介 setTimeout 只执行一次 setInterval 不停地重复执行函数s，etInterval(函数名, 重复执行的时间间隔毫秒数 ); clearInterval 终止重复执行 document.write() 不要在setInterval调用的函数中使用document.write(); 3、DOMDOM(Document Object Model)是一套对文档的内容进行抽象和概念化的方法。 当网页被加载时，浏览器会创建页面的文档对象模型，HTML DOM模型被构造为对象的树。 HTML文档树 DOM标准规定HTML文档中的每个成分都是一个节点(node)： 文档节点(document对象)：代表整个文档 元素节点(element 对象)：代表一个元素（标签） 文本节点(text对象)：代表元素（标签）中的文本 属性节点(attribute对象)：代表一个属性，元素（标签）才有属性 注释是注释节点(comment对象)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端总结]]></title>
    <url>%2F2019%2F12%2F02%2F%E5%89%8D%E7%AB%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引言前端部分的HTML+CSS总结 [TOC] 一、HTML部分： HTML是（Hyper Text Markup Language）超文本标记语言 的缩写 1、基本元素1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;tag_01&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;一号标题&lt;/h1&gt; &lt;p&gt;段落&lt;/p&gt; &lt;b&gt;粗体&lt;/b&gt;&amp;nbsp;&lt;strong&gt;带强调意义的粗体&lt;/strong&gt;&lt;br /&gt; &lt;i&gt;斜体&lt;/i&gt;&amp;nbsp;&lt;em&gt;带强调意义的斜体&lt;/em&gt;&lt;br /&gt; &lt;p&gt;预格式，是保证标记里面内容格式不变&lt;/p&gt; &lt;pre&gt; public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World"); &#125; &#125; &lt;/pre&gt; &lt;ins&gt;下划线&lt;/ins&gt;&lt;br /&gt; &lt;del&gt;删除效果&lt;/del&gt;&lt;/body&gt;&lt;/html&gt; 页面展示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;tag_02&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;图片标签&lt;/p&gt; &lt;div align="center"&gt; &lt;img src="https://how2j.cn/example.gif" alt="替换图片文字"&gt; &lt;/div&gt; &lt;!--alt表示当图片不存在时的，替换文字--&gt; &lt;p&gt;超链接&lt;/p&gt; &lt;a href="页面跳转的地址"&gt;超链接显示文本&lt;/a&gt; &lt;br /&gt; &lt;p&gt;表格相关知识&lt;/p&gt; &lt;!--border表示表格带边框--&gt; &lt;table border="1"&gt; &lt;tr&gt; &lt;!--单元格宽度的绝对值，同列的会自动继承--&gt; &lt;!--align表示设置表格内文本内容位置--&gt; &lt;td width="50px" align="right"&gt;1&lt;/td&gt; &lt;td rowspan="2"&gt;2,3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align="center"&gt;4&lt;/td&gt; &lt;td &gt;5&lt;/td&gt; &lt;!--bgcolor设置背景色--&gt; &lt;td bgcolor="pink"&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align="left"&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;td&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;!--合并三列--&gt; &lt;tr&gt; &lt;td colspan="3" align="center"&gt;a,b,c&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;列表&lt;/p&gt; &lt;p&gt;无序列表&lt;/p&gt; &lt;ul&gt; &lt;li&gt;无序1&lt;/li&gt; &lt;li&gt;无序2&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;有序列表&lt;/p&gt; &lt;ol&gt; &lt;li&gt;有序1&lt;/li&gt; &lt;li&gt;有序2&lt;/li&gt; &lt;/ol&gt; &lt;!--div布局器，配合CSS实现页面布局--&gt; &lt;div&gt;这是一个div&lt;/div&gt; &lt;div&gt;这是第二个div&lt;/div&gt; &lt;span&gt;这是一个Span&lt;/span&gt; &lt;span&gt;这是第二个Span&lt;/span&gt; &lt;pre&gt; div是块元素，即自动换行 常见的块元素还有h1,table,p span是内联元素，即不会换行 常见的内联元素还有img,a,b,strong &lt;/pre&gt; &lt;p&gt;字体&lt;/p&gt; &lt;font color="green"&gt;绿色默认大小字体&lt;/font&gt;&lt;br&gt; &lt;font color="red" size="+2"&gt;红色大2号字体&lt;/font&gt; &lt;p&gt;内敛框架&lt;/p&gt; &lt;iframe src="https://how2j.cn" &gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 页面展示 2、表单元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表单元素&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--formb表单用于向服务器提交数据--&gt; &lt;form action="post"&gt; 文本框：&lt;input type="text"&gt;&lt;br /&gt; 密码框：&lt;input type="password"&gt;&lt;br /&gt; &lt;p&gt;--------------------&lt;/p&gt; &lt;!-- 若没有分组，就会出现多选的情况,分组即name相同 --&gt; 单选框：单选1 &lt;input type="radio" name="r1" checked="checked"&gt;单选2 &lt;input type="radio" name="r1"&gt;&lt;br&gt; &lt;p&gt;--------------------&lt;/p&gt; 复选框：&lt;br&gt; &lt;!-- 一般要加上Value值不然，表单提交后得不到所选项 --&gt; 复选1&lt;input type="checkbox" value="复选1"&gt; 复选2&lt;input type="checkbox" value="复选2"&gt; 复选3&lt;input type="checkbox" value="复选3"&gt;&lt;br/&gt; &lt;p&gt;--------------------&lt;/p&gt; 下拉列表框：&lt;br&gt; &lt;!-- select的size属性可以设置多个复选项合并 --&gt; &lt;!-- select的multiple="multiple"可以多选 --&gt; &lt;select &gt; &lt;option value="1" selected="selected"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;p&gt;--------------------&lt;/p&gt; 文本域：&lt;br&gt; &lt;textarea name="" id="" cols="30" rows="10"&gt;天天向上，好好学习，早日过六级 &lt;/textarea&gt;&lt;br&gt; &lt;p&gt;--------------------&lt;/p&gt; 普通按钮：&lt;input type="button" value="按钮"&gt;&lt;br&gt; 提交按钮：&lt;input type="submit" value="提交"&gt;&lt;br&gt; 重置按钮:&lt;input type="reset" value="重置"&gt;&lt;br&gt; &lt;!-- button标签，内容可以为文字或图片 --&gt; &lt;button type="submit"&gt;按钮&lt;/button&gt;&lt;br&gt; &lt;button&gt;&lt;img src="https://how2j.cn/example.gif" alt=""&gt;&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; :kissing_smiling_eyes:页面展示 二、CSS语法1、CSS思维导图 2、CSS应用例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;CSS-Demo.01&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body&#123; font-family:"宋体"; font-size:13px; color:#666666; width:643px; &#125; .bold&#123; font-weight: bold; &#125; div.topdiv&#123; border-bottom-style: solid; border-bottom-color: silver; border-bottom-width: 1; padding-bottom: 10px; margin-bottom: 15px; &#125; .floatright&#123; float:right; &#125; .floatleft&#123; float:left; &#125; a&#123; text-decoration: none; color:#336699; &#125; div#thirdDiv span&#123; color:darkgray; &#125; div.clearLeft&#123; clear:left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="topdiv"&gt; &lt;img style="margin-right: 5px" src="img/1.png" alt=""&gt; &lt;span class="bold"&gt;最新动态&lt;/span&gt; &lt;span class="floatright"&gt;设置&lt;/span&gt; &lt;img src="img/2.png" style="margin-right: 5px" class="floatright"&gt; &lt;/div&gt; &lt;div id="left" class="floatleft" style="margin-right: 15px"&gt; &lt;img src="img/4.png" alt=""&gt;&lt;br&gt; &lt;br&gt; &lt;span style="background-image: url(img/5.png);padding: 5px"&gt;6551&lt;/span&gt; &lt;/div&gt; &lt;div id="right" class="floatleft show1"&gt; &lt;div style="margin-bottom: 5px"&gt; &lt;span&gt;热门回答，来自 机械&lt;/span&gt; &lt;a href="#"&gt;关注话题&lt;/a&gt; &lt;img src="img/3.png" class="floatright"&gt; &lt;/div&gt; &lt;div&gt; &lt;a class="bold"&gt;人类史上令人叹为观止的极限精度制造成果有哪些？&lt;/a&gt; &lt;p class="text"&gt;&lt;b&gt;Vicent Fu&lt;/b&gt;, Materials Science,PhD&lt;/a&gt; &lt;/div&gt; &lt;img src="img/6.png" class="floatleft"/&gt; &lt;div class="floatleft text" style="line-height:170%;margin-left:15px;width:367px"&gt; 说到精度，就不得不提在材料学中最重要的一个方面：表征。要项研究一种材料性能，握在手里把玩时远远不够的，就算你拿出放大镜离近了看，也只能看到表面的一些坑坑洼洼，而为了知晓一种材料的纤维结构，科学家至少要下到纳米级（放大千倍），如果要获得更深... &lt;a href=""&gt;显示全部 &lt;/a&gt; &lt;br&gt; &amp;nbsp; &lt;/div&gt; &lt;div id="thirdDiv"&gt; &lt;img src="img/7.png"&gt; &lt;span&gt;关注问题&lt;/span&gt; &lt;img src="img/8.png"&gt; &lt;span&gt;867条评论&lt;/span&gt; &lt;img src="img/9.png"&gt; &lt;span&gt;作者保留权利&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="clearLeft" &gt;&lt;/div&gt; &lt;!-- 清除浮动 --&gt; &lt;div id="bottom" style="margin-top:20px;border-top-style:solid;border-top-width:1px;border-top-color:#ddd"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 页面展示 后面还需继续总结，前端太厉害了—]]></content>
      <categories>
        <category>HTML</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsoup]]></title>
    <url>%2F2019%2F11%2F03%2FJsoup%2F</url>
    <content type="text"><![CDATA[Jsoup是一款Java的HTML解析器,主要用来对HTML解析。 :artificial_satellite:官方中文文档 :cowboy_hat_face:个人总结思维导图 :open_mouth:EG. 爬取腾讯首页全部图片12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.company;import org.jsoup.Connection;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.*;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;import java.net.URLEncoder;public class meizi &#123; /** * 下载图片到指定目录 * * @param filePath 文件路径 * @param imgUrl 图片URL */ public static void downImages(String filePath, String imgUrl) &#123; // 若指定文件夹没有，则先创建 File dir = new File(filePath); if (!dir.exists()) &#123; dir.mkdirs(); &#125; // 截取图片文件名 String fileName = imgUrl.substring(imgUrl.lastIndexOf('/') + 1, imgUrl.length()); try &#123; // 文件名里面可能有中文或者空格，所以这里要进行处理。但空格又会被URLEncoder转义为加号 String urlTail = URLEncoder.encode(fileName, "UTF-8"); // 因此要将加号转化为UTF-8格式的%20 imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('/') + 1) + urlTail.replaceAll("\\+", "\\%20"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; // 写出的路径 File file = new File(filePath + File.separator + fileName); try &#123; // 获取图片URL URL url = new URL(imgUrl); // 获得连接 URLConnection connection = url.openConnection(); // 设置10秒的相应时间 connection.setConnectTimeout(10 * 1000); // 获得输入流 InputStream in = connection.getInputStream(); // 获得输出流 BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file)); // 构建缓冲区 byte[] buf = new byte[1024]; int size; // 写入到文件 while (-1 != (size = in.read(buf))) &#123; out.write(buf, 0, size); &#125; out.close(); in.close(); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; // 利用Jsoup获得连接 Connection connect = Jsoup.connect("http://www.qq.com"); try &#123; // 得到Document对象 Document document = connect.get(); // 查找所有img标签 Elements imgs = document.getElementsByTag("img"); System.out.println("共检测到下列图片URL："); System.out.println("开始下载"); // 遍历img标签并获得src的属性 for (Element element : imgs) &#123; //获取每个img标签URL "abs:"表示绝对路径 String imgSrc = element.attr("abs:src"); // 打印URL System.out.println(imgSrc); //下载图片到本地 meizi.downImages("d:/img", imgSrc); &#125; System.out.println("下载完成"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>WebMagic</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>WebMagic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2019%2F10%2F30%2FMaven%2F</url>
    <content type="text"><![CDATA[Maven是专门用于构建和管理Java相关项目的工具。 一、Maven下载和配置 官方下载： http://maven.apache.org/download.cgi Maven的主要用途是： 1、相同的项目结构 ​ 1) 有一个pom.xml用于维护当前项目都用了那些jar包 ​ 2)所有的java代码都放在src/main/java下面 ​ 3)所有的测试代码都放在src/test/java下面 2、统一维护jar包 ​ 所有的jar包都放在”仓库“ 里，然后哪个项目需要用到这个jar包，只需要给出jar包的名称和版本号就行了。 这样jar包就实现了共享 二、Maven仓库 所谓的仓库就是存放项目需要的jar包的。 Maven采用一个仓库，多个项目的方式，让多个项目共享一个仓库里的相同jar包。 maven 会默认从maven官方提供的服务器下载jar包。而官方服务器在国外，因为大家都知道的原因，网速很慢，而且容易卡断。 为了便于快速下载相关jar包，可以使用国内maven 阿里云的下载地址：使用阿里云下载路径 命令行创建maven项目： mvn archetype:generate -DgroupId=com.XXX -DartifactId=j2se -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false archetype:generate 表示创建个项目-DgroupId 项目包名: com.XXX-DartifactId 项目名称: j2se-DarchetypeArtifactId 项目类型: maven-archetype-quickstart-DinteractiveMode:false 表示前面参数都给了，就不用一个一个地输入了 运行package命令： mvn package 注： 运行这个命令之前要先把当前路径切换到 j2se来 cd j2se package做了很多事情，编译，测试，打包，最后生成了一个j2se-1.0-SNAPSHOT.jar包 最后会看到一个绿色的BUILD SUCCESS 执行Jar： java -cp target/j2se-1.0-SNAPSHOT.jar com.XXX.App]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j使用总结]]></title>
    <url>%2F2019%2F10%2F29%2Flog4j%2F</url>
    <content type="text"><![CDATA[日志是应用软件中不可缺少的部分，Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录。 在apache网站：jakarta.apache.org/log4j 可以免费下载到Log4j最新版本的软件包。 一、Log4j的基本使用方法1、新建一个Java工程，导入log4j-1.2.17.jar 2、src同级创建并设置log4j.properties #配置根Loggerlog4j.rootLogger = [ level ] , appenderName1 , appenderName2 , …#配置日志信息输出目的地Appenderlog4j.appender.appenderName = fully.qualified.name.of.appender.class log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.optionN = valueN#配置日志信息的格式（布局）log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.option1 = value1 … log4j.appender.appenderName.layout.optionN = valueN 其中 [level] 是日志输出级别，共有5级： FATAL 0ERROR 3WARN 4INFO 6DEBUG 7 Appender 为日志输出目的地，Log4j提供的appender有以下几种： ​ org.apache.log4j.ConsoleAppender（控制台），org.apache.log4j.FileAppender（文件），org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） Layout：日志输出格式，Log4j提供的layout有以下几种： ​ org.apache.log4j.HTMLLayout（以HTML表格形式布局），org.apache.log4j.PatternLayout（可以灵活地指定布局模式），org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） 打印参数: Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，如下 ​ %m 输出代码中指定的消息 %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“/r/n”，Unix平台为“/n” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日 22 ： 10 ： 28 ， 921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 ) 应用举例： 1234567891011121314151617181920212223242526272829### 设置高于DEBUG级别的日志输出到控制台,D,E是别名###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制台 ### #ConsoleAppender控制台log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.out #PatternLayout是布局格式log4j.appender.stdout.layout = org.apache.log4j.PatternLayout #ConversionPattern布局显示器log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=E://logs/error.log ### #DailyRollingFileAppender每天只产生一个日志文件log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = true #Threshold限制只输出ERROR级别以上的日志log4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n 除了使用log4j.properties,也可以使用xml格式进行配置。 如： 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE log4j:configuration PUBLIC "-//log4j/log4j Configuration//EN" "log4j.dtd"&gt; &lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"&gt; &lt;appender name="STDOUT" class="org.apache.log4j.ConsoleAppender"&gt; &lt;layout class="org.apache.log4j.PatternLayout"&gt; &lt;param name="ConversionPattern" value="%d %-5p %c.%M:%L - %m%n"/&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- specify the logging level for loggers from other libraries --&gt; &lt;logger name="com.opensymphony"&gt; &lt;level value="ERROR" /&gt; &lt;/logger&gt; &lt;logger name="org.apache"&gt; &lt;level value="ERROR" /&gt; &lt;/logger&gt; &lt;logger name="org.hibernate"&gt; &lt;level value="ERROR" /&gt; &lt;/logger&gt; &lt;!-- for all other loggers log only debug and above log messages --&gt; &lt;root&gt; &lt;priority value="ERROR"/&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;/log4j:configuration&gt; 3、设置日志内容 1234567891011121314151617181920212223package log4j;import org.apache.log4j.Logger;import org.apache.log4j.PropertyConfigurator;public class TestLog4j &#123; //获取日志记录器，得到本类的字节码文件 static Logger logger = Logger.getLogger(TestLog4j.class); public static void main(String[] args) &#123; //Log4j日志格式指定配置文件 PropertyConfigurator.configure("log4j.properties"); for (int i = 0; i &lt; 10; i++) &#123; //调用对应方法 logger.trace("跟踪信息"); logger.debug("调试信息"); logger.info("输出信息"); logger.warn("警告信息"); logger.error("错误信息"); logger.fatal("致命信息"); &#125; &#125;&#125; 二、Web项目中使用Log4j:call_me_hand:在J2EE应用使用log4j，必须先在启动服务时加载Log4j的配置文件进行初始化，可以在web.xml中进行。 1、web应用的log4j使用基本上都采用：新建一个servlet，这个servlet在init函数中为log4j执行配置。一般就是读入配置文件，所以需要在web.xml中为这个servlet配置，同时设定load-on-startup为1。 2、这个servlet配置log4j就是读出配置文件，然后调用configure函数。这里有两个问题： ​ 1）需要知道文件在哪里 ​ 2）需要正确的文件类型 3、配置文件位置在web.xml中配置一个param即可，路径一般是相对于web的root目录 4、文件类型一般有两种，一个是Java的property文件，另一种是xml文件 1234567891011121314151617181920212223242526272829&lt;xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="htt p://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;LogLearning&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;Log4JTestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.mucfc.Log4JTestServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--用来启动 log4jConfigLocation的servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;Log4JInitServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.mucfc.Log4JInitServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;log4j-properties-location&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/log4j.properties&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Log4JTestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/test&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易的JDBC模板类]]></title>
    <url>%2F2019%2F10%2F25%2F%E7%AE%80%E6%98%93%E7%9A%84JDBC%E6%A8%A1%E6%9D%BF%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[简单的JDBC模板 参考的链接： 1.tb.user:用户信息表 12345678910CREATE TABLE tb_user( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(10) null, age INT null, gender CHAR(2) null, password varchar(15) null, telephone varchar(11) null, birthday date null); 2.db.propeties:数据库连接配置文件 事先要导入驱动程序：&lt; a herf=”/mysql-connector-java-5.0.8-bin.jar”&gt;mysql-connector-java-5.0.8-bin.jar 12345678#jdbc MySQL数据库驱动DriverName=com.mysql.jdbc.Driver#数据库的连接地址，phaseiv为需要用到的表所在的数据库名Url=jdbc:mysql://localhost:3306/phaseiv?serverTimezone=UTC#数据库的用户名UserName=#数据库密码UserPassword= Oracle数据库连接 #jdbc数据库驱动jdbc.driverClassName=oracle.jdbc.driver.OracleDriver #数据库的连接地址jdbc.url=jdbc:oracle:thin:@127.0.0.1:1521:XE 开发中使用properties配置文件，方便后期维护。 文件位置： 任意，建议src下 文件名称：任意，扩展名为properties 文件内容：一行一组数据，格式“key=value” key 命名自定义，如果是多单词，习惯使用点分割，例如jdbc.driver value 值不支持中文，如果有需要使用非英文字符，将进行Unicode转化 配置文件只需要加载一次，提供静态代码，当前类被加载到内存执行 3.ConfigUtil.java:black_heart::读取数据库连接的配置文件的工具类 处于工具层（utils） 123456789101112131415161718192021222324252627282930313233343536import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** @ClassName: ConfigUtil * @Description: 读取数据库配置文件中的工具类 */public class ConfigUtil &#123; private static Properties properties; // 读取数据库配置文件 private static InputStream inputStream = ConfigUtil.class.getResourceAsStream("/db.properties"); //静态初始化块 static &#123; properties = new Properties(); try &#123; properties.load(inputStream); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; properties.getProperty("Url"); properties.getProperty("UserName"); properties.getProperty("UserPassword"); properties.getProperty("DriverName"); &#125; //获取数据库配置 static Properties getProperties() &#123; return properties; &#125;&#125; 4.DBUtil : 连接数据库的工具类 12345678910111213141516171819202122232425262728293031323334353637383940import java.sql.Connection;import java.sql.DriverManager;/** @ClassName: DBUtil * @Description: 连接数据库的工具类 */public class DBUtil &#123; private static Connection connection; //获取数据库的配置信息 private static String URL = ConfigUtil.getProperties().getProperty("Url"); private static String USER = ConfigUtil.getProperties().getProperty("UserName"); private static String PASSWORD = ConfigUtil.getProperties().getProperty("UserPassword"); private static String DRIVER_NAME = ConfigUtil.getProperties().getProperty("DriverName"); //加载数据库驱动 static &#123; try &#123; Class.forName(DRIVER_NAME); &#125; catch (ClassNotFoundException e) &#123; System.err.println("error: fail to init the driver of database"); throw new ExceptionInInitializerError(e); &#125; &#125; //获取数据库连接 public static Connection getConnection() &#123; if (connection == null) &#123; try &#123; connection = DriverManager.getConnection(URL, USER, PASSWORD); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return connection; &#125;&#125; 5.User.java: 用户信息类 处于bean层，数据的载体 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class User &#123; private Integer id; private String name; private Integer age; private String gender; private String password; private String telephone; private String birthday; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getTelephone() &#123; return telephone; &#125; public void setTelephone(String telephone) &#123; this.telephone = telephone; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return "User [id=" + id + ", name=" + name + ", age=" + age + ", gender=" + gender + ", password=" + password + ", telephone=" + telephone + ", birthday=" + birthday + "]"; &#125; &#125; 6.UserDao.java : 数据访问层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.sql.Connection;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import com.mysql.jdbc.PreparedStatement;import com.mysql.jdbc.ResultSet;public class UserDao &#123; //获取数据库连接 private static Connection connection = DBUtil.getConnection(); //添加用户信息 public boolean insertNewUser(User user) &#123; String sql = "insert into tb_user(name, age, gender, password, telephone, birthday) values (?,?,?,?,?,?)"; try (PreparedStatement preparedStatement = (PreparedStatement) connection.prepareStatement(sql)) &#123; preparedStatement.setString(1, user.getName()); preparedStatement.setInt(2, user.getAge()); preparedStatement.setString(3, user.getGender()); preparedStatement.setString(4, user.getPassword()); preparedStatement.setString(5, user.getBirthday()); preparedStatement.setString(6, user.getTelephone()); return preparedStatement.executeUpdate() &gt; 0; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return false; &#125; //查询所有用户信息 public List&lt;User&gt; selectAllUser() &#123; String sql = "select id, name, age, gender, password, telephone, birthday from tb_user"; List&lt;User&gt; list = new ArrayList&lt;&gt;(); try (PreparedStatement preparedStatement = (PreparedStatement) connection.prepareStatement(sql)) ResultSet resultSet = (ResultSet) preparedStatement.executeQuery()) &#123; while (resultSet.next()) &#123; User user = new User(); user.setId(resultSet.getInt("id")); user.setName(resultSet.getString("name")); user.setAge(resultSet.getInt("age")); user.setGender(resultSet.getString("gender")); user.setPassword(resultSet.getString("password")); user.setTelephone(resultSet.getString("telephone")); user.setBirthday(resultSet.getString("birthday")); list.add(user); &#125; return list; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; //更新用户信息 public boolean updateUserById(User user) &#123; String sql = "UPDATE tb_user SET name = ? , gender = ? , age = ? , password = ?, birthday = ?, telephone = ? where id = ?"; try &#123; PreparedStatement preparedStatement = (PreparedStatement) connection.prepareStatement(sql); preparedStatement.setString(1, user.getName()); preparedStatement.setString(2, user.getGender()); preparedStatement.setInt(3, user.getAge()); preparedStatement.setString(4, user.getPassword()); preparedStatement.setString(5, user.getBirthday()); preparedStatement.setString(6, user.getTelephone()); preparedStatement.setInt(7, user.getId()); return preparedStatement.executeUpdate() &gt; 0; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return false; &#125; //删除用户信息 public boolean deleteUserById(Integer id) &#123; String sql = "delete from tb_user where id = ?"; try &#123; PreparedStatement preparedStatement = (PreparedStatement) connection.prepareStatement(sql); preparedStatement.setInt(1, id); return preparedStatement.executeUpdate() &gt; 0; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125; 7.UserService.java : 业务逻辑层 123456789101112import java.util.List;public interface UserService &#123; List&lt;User&gt; getAllUser(); boolean addUser(User user); boolean updateUser(User user); boolean deleteUser(Integer id);&#125; 8.UserServiceImpl.java : 业务逻辑层的实现类 1234567891011121314151617181920212223242526import java.util.List;public class UserServiceImpl implements UserService &#123; private static UserDao userDao = new UserDao(); @Override public List&lt;User&gt; getAllUser() &#123; return userDao.selectAllUser(); &#125; @Override public boolean addUser(User user) &#123; return userDao.insertNewUser(user); &#125; @Override public boolean updateUser(User user) &#123; return userDao.updateUserById(user); &#125; @Override public boolean deleteUser(Integer id) &#123; return userDao.deleteUserById(id); &#125;&#125; 9.AppTest.java : 程序测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.List;/** * Unit test for simple App. */public class AppTest &#123; private static UserService userService; @BeforeClass public static void init() &#123; userService = new UserServiceImpl(); &#125; //test getAllUser() method @Test public void printAllUser() &#123; List&lt;User&gt; allUsers = userService.getAllUser(); System.out.println("获取所有的用户信息 : " + allUsers); &#125; //test addUser method @Test public void addUser() &#123; User user = new User(); user.setName("addUser"); user.setGender("男"); user.setAge(0); user.setPassword("pwd"); user.setTelephone("000000"); user.setBirthday("0000-00-00"); System.out.println("是否成功添加用户信息 : " + userService.addUser(user)); &#125; //test updateUser method @Test public void updateUser() &#123; User user = new User(); user.setId(1); user.setName("updateUser"); user.setGender("女"); user.setAge(0); user.setPassword("pwd"); user.setTelephone("111111"); user.setBirthday("1111-11-11"); System.out.println("是否成功更新用户信息 : " + userService.updateUser(user)); &#125; //test deleteUser method @Test public void deleteUser() &#123; System.out.println("是否成功删除用户信息 : " + userService.deleteUser(1)); &#125;&#125; @Test标签是为了不写mian方法，使用junit测试设计的一个小功能。 一个JUnit4的单元测试用例执行顺序为：@BeforeClass -&gt; @Before -&gt; @Test -&gt; @After -&gt; @AfterClass; 使用junit就方便多了，这是单元测试，你想测哪个方法就写一个对应的测试方法，然后用junit运行。每个方法之间是独立的，非常灵活。 参考链接： https://blog.csdn.net/qq_40794973/article/details/83579049]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序员编程规范]]></title>
    <url>%2F2019%2F09%2F17%2FJava%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[程序员的自我修养：人类可读，计算机可执行 内容来自：《代码的整洁之道》 1、简单明了的名字普通变量： 使用具有实际意义且熟悉的单词，单词可缩写但尽量保留元音字母,首单词小写，以后各单词首字母大写。 不要使用大小写区别变量。 集合引用名用复数 包命名： 一个小写单词表示。 类命名: 类和接口的每个单词（名词）的首字母都要大写 具有成组相关属性，静态服务或者常量的类名字用复数形式 方法命名： ​ 1. 方法名中的第一个单词小写，其后每个单词的第一个字母大写 2. 用动词命名方法 3. 遵循JavaBean中命名属性访问函数方法：set，get，is 参数命名： 构造函数或者“set”方法给字段分配参数赋值，参数名应该和字段名相同 常量命名： 常量每个单词均大写，单词之间使用下划线连接 2、最好的程序员是代码即注释注释的功能是表达一些代码不足以解释其逻辑行为，要将自身代码细化，能让人顺着代码了解逻辑。 但是，为了节省时间，最好在代码逻辑（类、接口、字段和方法）前加上功能说明,并且每个包和每个应用程序编写概述。 注释尽量用//；对于所有的Javadoc注释，则使用/* /；而临时的逻辑代码块用/ */ 3、编程规范编程规范可减少对内存的需求量，加快代码的执行速度，同时降低程序的出错率。 设置类对象和类成员的访问控制权限，如（public和private） 调用类（静态）方法和类成员时，应该指明类名 使用括号明确操作顺序 尽量使用泛型 使用equals()，而不是==来检测对象的对等关系 方法尽量短小且职责单一 并发： 1.仅在适当的地方使用线程 同步： 1.避免同步 2.用同步的包装器，提供同步接口 3.如果方法包含几个不需要同步的重要操作，那么不要同步整个方法 4.读写实例变量的时候避免不必要的同步 5.使用notify()而不是notifyAll() 6.为同步初始化使用双重检查模式 效率： 1.使用懒惰初始化 2.避免创建不必要的对象 3.重新初始化并重新使用对象，尽量不要新建对象 4.Be Better! 任何时候效率优先，要在保证效率的情形下保证质量。没有事情是能一蹴而就的，写出好的代码，是一个循序渐进的过程，只有不断的通过实践积累经验，才能让我们少走弯路。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[典型相关]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[典型相关典型相关分析的基本思想与主成分分析非常相似。 首先在每组变量中找出变量的线性组合，使得两组的线性组合之间具有最大的相关系数； 然后选取和最初挑选的这对线性组合不相关的线性组合，使其配对，并选取相关系数最大的一对； 如此继续下去，直到两组变量之间的相关性被提取完毕为止。 被选出的线性组合配对称为典型变量，它们的相关系数称为典型相关系数。典型相关系数度量了这两组变量之间联系的强度。9]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>SPSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相关系数]]></title>
    <url>%2F2019%2F09%2F01%2F%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%2F</url>
    <content type="text"><![CDATA[相关系数 1、皮尔逊Person相关系数其可看成剔除了两个变量量纲影响，即X，Y变量标准化后的协方差。 只有数据满足连续，正态分布且线性相关时，才能使用皮尔逊相关系数来描述变量间的相关性 操作步骤： 1、对数据进行一下描述统计 2、相关性可视化，做出矩阵散点图（以上两步可均由SPSS实现，将数据复制到Excle中后要对表格进行一些设置） 3、检验数据是否为正态分布 正态分布JB检验（大样本 n&gt;30） MATLAB中进行JB检验的语法：[h,p] = jbtest(x,alpha) 当输出h等于1时，表示拒绝原假设；h等于0则代表不能拒绝原假设。alpha就是显著性水平，一般取0.05，此时置信水平为1-0.05=0.95x就是我们要检验的随机变量，注意这里的x只能是向量。 1234567891011121314%% 正态分布检验% 检验第一列数据是否为正态分布[h,p] = jbtest(Test(:,1),0.05)% 用循环检验所有列的数据n_c = size(Test,2); % number of column 数据的列数H = zeros(1,6);P = zeros(1,6);for i = 1:n_c[h,p] = jbtest(Test(:,i),0.05);H(i)=h;P(i)=p;enddisp(H)disp(P) Shapiro-wilk检验(小样本3≤n≤50) 使用spss操作,描述统计-&gt;探索-&gt;图-&gt;含检验的正态图 4、得到一个有显著性标记的相关性系数表格 2、Spearman相关性系数 [R,P]=corr(Test,’type’,’spearman’) 斯皮尔曼相关系数和皮尔逊相关系数选择:1.连续数据，正态分布，线性关系，用pearson相关系数是最恰当，当然用spearman相关系数也可以， 就是效率没有pearson相关系数高。2.上述任一条件不满足，就用spearman相关系数，不能用pearson相关系数。3.两个定序数据之间也用spearman相关系数，不能用pearson相关系数。定序数据是指仅仅反映观测对象等级、顺序关系的数据，是由定序尺度计量形成的，表现为类别，可以进行排序，属于品质数据。]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>SPSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遗传算法]]></title>
    <url>%2F2019%2F08%2F10%2F%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[遗传算法 1、什么是遗传算法1.1 定义遗传算法(Genetic Algorithm GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。 其主要特点是直接队结构体对象进行操作，不存在求导和函数连续性的限定； 具有内在的隐并性和更好的全局寻优能力； 采用概率化的寻优方法，不需要确定的规则就能自动获取和指导优化的搜索空间，自适应地调整搜索方向。 1.2 遗传算法执行过程 遗传算法是从代表问题可能潜在的解集的一个种群（population）开始的，而一个种群则由经过基因（gene）编码的一定数目的个体(individual)组成。每个个体实际上是染色体(chromosome)带有特征的实体。 染色体作为遗传物质的主要载体，即多个基因的集合，其内部表现（即基因型）是某种基因组合，它决定了个体的形状的外部表现，我们往往进行简化，如二进制编码。 初始群体产生后，按照适者生存和优胜劣汰的原理，逐代演化出越来越好的近似解，在每一代，根据适应度大小选择个体，并借助于自然遗传双子进行组合交叉和变异，产生出代表新的解集的种群。 这个过程将导致种群像自然进化一样的后生种群比前代更加适应于环境，末代种群中的最有个体经过解码，可以作为问题的近似最优解。 1.3 相关术语为了更好了解遗传算法，在此之前先简单介绍一下相关生物学术语 基因型(genotype)：性状染色体的内部表现； 表现型(phenotype)：染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现； 进化(evolution)：种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的。 适应度(fitness)：度量某个物种对于生存环境的适应程度。 选择(selection)：以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程。 复制(reproduction)：细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。 交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交； 变异(mutation)：复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状。 编码(coding)：DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射。 解码(decoding)：基因型到表现型的映射。 个体（individual）：指染色体带有特征的实体； 种群（population）：个体的集合，该集合内个体数称为种群 2、实现过程（1）建立表现型和基因型的映射关系，数字化编码​ 编码是应用遗传算法时要解决的首要问题，也是设计遗传算法 时的一个关键步骤。编码方法影响到交叉算 子、变异算子等遗传算子的运算方法，大很大程度上决定了遗传进化的效率。 ​ a、二进制编码 它由二进制符号0和1所组成的二值符号集。它有以下一些优点： 编码、解码操作简单易行 交叉、变异等遗传操作便于实现 合最小字符集编码原则 利用模式定理对算法进行理论分析。 二进制编码的缺点是：对于一些连续函数的优化问题，由于其随机性使得其局部搜索能力较差，如对于一些高精度的问题（如上题），当解迫近于最优解后，由于其变异后表现型变化很大，不连续，所以会远离最优解，达不到稳定。 ​ b、浮点编码法 所谓浮点法，是指个体每个基因值用某一范围内的一个浮点数来表示。在浮点数编码方法中，必须保证基因值在给定的区间限制范围内，遗传算法中使用的交叉、变异等遗传算子也必须保证其运算结果所产生的新个体的基因值也在这个区间限制范围内。 浮点数编码方法有下面几个优点： 适用于在遗传算法中表示范围较大的数 适用于精度要求较高的遗传算法 便于较大空间的遗传搜索 改善了遗传算法的计算复杂性，提高了运算交率 便于遗传算法与经典优化方法的混合使用 便于设计针对问题的专门知识的知识型遗传算子 便于处理复杂的决策变量约束条件 ​ c、符号编码法 符号编码法是指个体染色体编码串中的基因值取自一个无数值含义、而只有代码含义的符号集如｛A,B,C…｝。符号编码的主要优点是： 符合有意义积术块编码原则 便于在遗传算法中利用所求解问题的专门知识 便于遗传算法与相关近似算法之间的混合使用。 （2）评价个体的适应度–适应度函数​ 评价个体适应度的一般过程： 1. 对个体编码串进行解码处理后，可得到个体的表现型。 2. 由个体的表现型可计算出对应个体的目标函数值。 3. 根据最优化问题的类型，由努比奥函数值按一定的转换规则求出个体的适应度。 （3）选择函数遗传算法中的选择操作就是用来确定如何重父代群体中按某种方法选取那些个体，以便遗传到下一代群体。选择操作用来确定重组或交叉个体，以及被选个体将产生多少个子代个体。 常用的选择算子： 1、轮盘赌选择：是一种回放式随机采样方法。每个个体进入下一代的概率等于他的适应度值与整个种群中个体适应度值和的比例。选择误差大 2、随机竞争选择：每次按轮盘赌选择一对个体，然后让这两个个体间进行竞争，适应度高的被选中，如此反复，直到选满为止。 3、最佳保留选择：首先按轮盘赌选择方法执行遗传算法的选择操作，然后将当前群体中适应度最高的个体结构完整地赋值到下一代群体中。 4、无回放随机选择（也叫期望值选择Excepted Value Selection）：根据每个个体在下一代群体中的生存期望来进行随机选择运算。方法如下: （1） 计算群体中每个个体在下一代群体中的生存期望数目N。 （2） 若某一个体被选中参与交叉运算，则它在下一代中的生存期望数目减去0.5，若某一个体未 被选中参与交叉运算，则它在下一代中的生存期望数目减去1.0。 （3） 随着选择过程的进行，若某一个体的生存期望数目小于0时，则该个体就不再有机会被选中。 5、确定式选择：一种确定的方式来进行选择操作。具体操作过程如下： （1） 计算群体中各个个体在下一代群体中的期望生存数目N。 （2） 用N的整数部分确定各个对应个体在下一代群体中的生存数目。 （3） 用N的小数部分对个体进行降序排列，顺序取前M个个体加入到下一代群体中。至此可完全确定出下一代群体中Ｍ个个体。 6、无回放余数随机选择：可确保适应度比平均适应度大的一些个体能够被遗传到下一代群体中，因而选择误差比较小。 7、均匀排序：对群体中的所有个体按期适应度大小进行排序，基于这个排序来分配各个个体被选中的概率。 8、最佳保存策略：当前群体中适应度最高的个体不参与交叉运算和变异运算，而是用它来代替掉本代群体中经过交叉、变异等操作后所产生的适应度最低的个体。 9、随机联赛选择：每次选取几个个体中适应度最高的一个个体遗传到下一代群体中。 10、排挤选择：新生成的子代将代替或排挤相似的旧父代个体，提高群体的多样性。 实例 假如有５条染色体，他们的适应度分别为５、８、３、７、２。 那么总的适应度为：F = 5 + 8 + 3 + 7 + 2 = 25。 那么各个个体的被选中的概率为： α1 = ( 5 / 25 ) * 100% = 20% α2 = ( 8 / 25 ) * 100% = 32% α3 = ( 3 / 25 ) * 100% = 12% α4 = ( 7 / 25 ) * 100% = 28% α5 = ( 2 / 25 ) * 100% = 8% 所以转盘如下： 当指针在这个转盘上转动，停止下来时指向的个体就是天选之人啦。可以看出，适应性越高的个体被选中的概率就越大。 (4)遗传–染色体交叉遗传算法中的交叉操作，是指两队相互配对的染色体按某种方式相互交换其部分基因，从而形成两个新的个体。 适用于二进制编码或浮点数编码个体的交叉算子： 单点交叉：指在个体编码串中只堆积设置一个交叉点，然后再该点相互交换配对个体的部分染色体。 两点交叉与多点交叉： (1) 两点交叉（Two-point Crossover）：在个体编码串中随机设置了两个交叉点，然后再进行部分基因交换。 (2) 多点交叉（Multi-point Crossover） 均匀交叉（也称一致交叉，Uniform Crossover）：两个配对个体的每个基因座上的基因都以相同的交叉概率进行交换，从而形成两个新个体。 算术交叉（Arithmetic Crossover）：由两个个体的线性组合而产生出两个新的个体。该操作对象一般是由浮点数编码表示的个体。 （5）变异–基因突变遗传算法中变异运算，是指将个体染色体编码串中的某些基因座上的基因值用该基因座上其他等位基因来替换，从而产生新的个体。 以下变异算子适用于二进制编码和浮点数编码的个体： 基本位变异（Simple Mutation）：对个体编码串中以变异概率、随机指定的某一位或某几位仅因座上的值做变异运算。 均匀变异（Uniform Mutation）：分别用符合某一范围内均匀分布的随机数，以某一较小的概率来替换个体编码串中各个基因座上的原有基因值。（特别适用于在算法的初级运行阶段） 边界变异（Boundary Mutation）：随机的取基因座上的两个对应边界基因值之一去替代原有基因值。特别适用于最优点位于或接近于可行解的边界时的一类问题。 非均匀变异：对原有的基因值做一随机扰动，以扰动后的结果作为变异后的新基因值。对每个基因座都以相同的概率进行变异运算之后，相当于整个解向量在解空间中作了一次轻微的变动。 高斯近似变异：进行变异操作时用符号均值为Ｐ的平均值，方差为P**2的正态分布的一个随机数来替换原有的基因值。]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINGO入门]]></title>
    <url>%2F2019%2F08%2F08%2FLINGO%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[主成分分析]]></title>
    <url>%2F2019%2F08%2F08%2F%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[主成分分析 注意事项 1）主成分分析的结果受量纲的影响，由于各变量的单位可能不一样，如果各自改变量纲，结果会不一样，这是主成分分析的大问题，回归分析是不存在这种情况的， 所以实际中可以先把各变量的数据标准化，然后使用协方差矩阵或相关系数矩阵进行分 析。 2）为使方差达到大的主成分分析，所以不用转轴（由于统计软件常把主成分分 析和因子分析放在一起，后者往往需要转轴，使用时应注意）。 3）主成分的保留。用相关系数矩阵求主成分时，Kaiser主张将特征值小于1的主成 分予以放弃（这也是SPSS软件的默认值）。 4）在实际研究中，由于主成分的目的是为了降维，减少变量的个数，故一般选取 少量的主成分（不超过5或6个），只要它们能解释变异的70％～80％（称累积贡献率） 就行了。 下面我们直接通过主成分估计（principle estimate）进一步阐述主成分分析的基本思想和相关概念。 123456789101112131415161718192021222324252627282930clc,clear load sn.txt %把原始的x1,x2,x3,x4,y的数据保存在纯文本文件sn.txt中 [m,n]=size(sn);num=3; %num为选取的主成分的个数 mu=mean(sn);sigma=std(sn); snb=zscore(sn); %数据标准化 b=snb(:,1:end-1); %x1,x2,x3,x4的数据赋给b r=cov(b); %标准化数据的协方差阵就是相关系数阵 [x,y,z]=pcacov(r); f=repmat(sign(sum(x)),size(x,1),1); x=x.*f; %各%以下是普通的小二乘法回归 r=[ones(m,1),b]\snb(:,end); %标准化数据的回归方程系数 bzh=mu./sigma; ch10=mu(end)-bzh(1:end-1)*r(2:end)*sigma(end) %原始数据的常数项 fr=r(2:end);fr=fr'; ch1=fr./sigma(1:end-1)*sigma(end) %原始数据的x1,x2等等系数 %以下是主成分回归 pval=b*x(:,1:num); rp=[ones(m,1),pval]\snb(:,end); %主成分数据的回归方程系数 beta=x(:,1:num)*rp(2:num+1); %标准化数据的回归方程系数 ch20=mu(end)-bzh(1:end-1)*beta*sigma(end) %原始数据的常数项 fr=beta'; ch2=fr./sigma(1:end-1)*sigma(end) %原始数据的x1,x2等等系数 check1=sqrt(sum((sn(:,1:end-1)*ch1'+ch10-sn(:,end)).^2)/(m-n)) check2=sqrt(sum((sn(:,1:end-1)*ch2'+ch20-sn(:,end)).^2)/(m-num-1)) 主成分分析函数pcacov函数说明： 123load haldcovx = cov(ingredients);[COEFF,latent,explained] = pcacov(covx) 输出变量：-coeff: 特征向量(注意与pca函数的变量score进行区分）；-latent: 特征值；[~,latent,coeff] = svd(v); 其实这里可以用eig函数替代latent = diag(latent);-explained：每个特征值占比，字面上即每个特征值对系统有多少解释，用百分比表示。explained=100*latent/sum(latent);]]></content>
      <categories>
        <category>主成分分析</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>主成分分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学建模总结]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[常用模型&amp;算法总结 总的来说，常用主成分分析来降维 综合评价的方法因子分析法、层次分析法、秩和比（RSR）法、Topsis法、模糊评价方法、灰色系统评价方法。必看完的资料 蒙特卡罗方法来随机模拟求解 数据处理：数据变换，数据拟合，参数估计，插值等 线性规划、整数规划、目标规划、动态规划类问题的求解关键在于根据题目已知信息找出约束条件与目标函数 通过插值or拟合or光滑技术【移动平均之类的】可以把离散数据连续化，通过分组【把数据划分成不同的小区间】or差分就可以把连续数据离散化.…。 组合优化算法常用于很难求出最优解的NP问题 跳转目录 [TOC] 【1】主成分分析用较少的变量去解释原来资料中大部分变异，把相关性很高的变量转换为彼此相关独立或不相关的变量，是一种降维方法。为减少指标某种程度上的关联性，即信息冗余，就需要将他们间不同的特征选出来，也就是降维，常用的降维方法有：主成分分析（PCA），SVD奇异值分解，逐步回归 【blog链接】 主成分分析（一）：基本思想与主成分估计方法 主成分分析法（二）：计算步骤 【2】LINGO入门 集部分是 LINGO 模型的一个可选部分。在 LINGO 模型中使用集之前，必须在集部分事先定义。集部分以关键字“sets:”开始以“endsets”结束。一个模型可以没有集部分，或有一个简单的集部分，或有多个集部分。一个集部分可以放置于模型的任何地方，但是一个集及其属性在模型约束中被引用之前必须定义了它们。 【3】相关系数 最常用的相关系数为皮尔逊Person和斯皮尔曼Spearman，用其来衡量两个变量间的相关性大小，根据数据满足的不同条件，选择不同的相关系数计算和分析。 ​ 只有两个变量是线性相关的情况下，才能用相关系数说明其相关程度如何。 【blog链接】 相关系数]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflection]]></title>
    <url>%2F2019%2F07%2F11%2FReflection%2F</url>
    <content type="text"><![CDATA[反射机制 反射的概念：在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。 Java可以通过一个配置文件来选择程序所调用的方法和类对象 使用反射机制的步骤： 获取类对象 调用某个对象的getClass()方法 Class p = new Hero().getClass(); 调用某个对象的class属性来获取该类对应的Class对象 Class p=new Hero().class; 使用Class类中的forName()静态方法（最安全/性能最好） Class p=Class.forName(“类的全部名称（包名.类名）”)； 获取方法和属性信息getField 只能获取public的，包括从父类继承来的字段。getDeclaredField 可以获取本类所有的字段，包括private的，但是不能获取继承来的字段。 (注： 这里只能获取到private的字段，但并不能访问该private字段的值,除非加上setAccessible(true)) 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;使用反射&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;package reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * 通过用户输入类的全路径，来获取该类的成员方法和属性 * Declared获取全部不管是私有和公有 * 1.获取访问类的Class对象 * 2.调用Class对象的方法返回访问类的方法和属性信息 */public class Test &#123; public static void main(String[] args) &#123; try &#123; //获取Person类的Class对象 Class clazz=Class.forName("reflection.Person"); //获取Person类的所有方法信息 Method[] method=clazz.getDeclaredMethods(); for(Method m:method)&#123; System.out.println(m.toString()); &#125; //获取Person类的所有成员属性信息 Field[] field=clazz.getDeclaredFields(); for(Field f:field)&#123; System.out.println(f.toString()); &#125; //获取Person类的所有构造方法信息 Constructor[] constructor=clazz.getDeclaredConstructors(); for(Constructor c:constructor)&#123; System.out.println(c.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 创建对象当我们获取到所需类的Class对象后，可以用它来创建对象，创建对象的方法有两种： 使用Class对象的newInstance()方法来创建该Class对象对应类的实例，但是这种方法要求该Class对象对应的类有默认的空构造器。 先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建 Class对象对应类的实例,通过这种方法可以选定构造方法创建实例。 1234567891011121314151617181920212223242526272829303132333435package reflection;import java.lang.reflect.Constructor;public class Demo01 &#123; public static void main(String[] args) &#123; try &#123; //获取Person类的Class对象 Class clazz=Class.forName("reflection.Person"); /** * 第一种方法创建对象 */ //创建对象 Person p=(Person) clazz.newInstance(); //设置属性 p.setName("张三"); p.setAge(16); p.setGender("男"); System.out.println(p.toString()); /** * 第二种方法创建 */ //获取构造方法 Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class); //创建对象并设置属性 Person p1=(Person) c.newInstance("李四","男",20); System.out.println(p1.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 调用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package reflection;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import charactor.ADHero;import charactor.APHero;import charactor.Hero;import java.lang.reflect.*;public class Test_03 &#123; public static void main(String[] args) &#123; read(); &#125; public static void read() &#123; File f = new File("E:\\Java\\j2se\\src\\reflection\\hero.config"); try(FileReader fi = new FileReader(f);BufferedReader br = new BufferedReader(fi); ) &#123; String line = br.readLine(); //charactor.APhero String line2 = br.readLine(); //garen String line3 = br.readLine(); //charactor.ADhero String line4 = br.readLine(); //teemo line.trim(); line2.trim(); line3.trim(); line4.trim(); APHero h1 = (APHero) Class.forName(line).newInstance(); ADHero h2 = (ADHero) Class.forName(line3).newInstance(); //通过反射拿到俩个对象 Hero h = new Hero(); Field f1 = h.getClass().getDeclaredField("name"); f1.set(h1, line2); f1.set(h2, line4); //通过反射 拿到他们的 name 字段 然后 设置 这两个Hero对象的 name 属性; Method m = h1.getClass().getMethod("attackHero", Hero.class); //Hero.class 代表参数类型是 Hero m.invoke(h1, h2); //通过反射 拿到 attackHero 这个方法 然后 通过反射调用方法 h1调用 传 h2 这个参数 &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125; 即我们可以不修改源文件，而只用修改.config文件，这样使得程序更健壮。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习（四）]]></title>
    <url>%2F2019%2F07%2F11%2FGraph%2F</url>
    <content type="text"><![CDATA[Graph &amp; 查找 &amp; 排序 第六章 图 拓扑排序算法描述： 把邻接表中入度为0的顶点依此进栈 若栈不空，则 栈顶元素vj退栈并输出； 在邻接表中查找vj的直接后继vk，把vk的入度减1；若vk的入度为0则进栈 若栈空时输出的顶点个数不是n，则有向图有环；否则，拓扑排序完毕。 所谓的线索化，就是按其要求的遍历顺序确定每个结点的前驱和后继，其中有左子节点的不用画前驱 第七章 查找顺序查找、折半查找、索引查找、分块查找是静态查找，动态查找有二叉排序树查找，最优二叉树查找，键树查找，哈希表查找 静态查找表顺序表的顺序查找：应用范围：顺序表或线性链表表示的表，表内元素之间无序。查找过程：从表的一端开始逐个进行记录的关键字和给定值的比较。 顺序有序表的二分查找。平均查找时间(n+1)/n log2(n+1) 分块查找：将表分成几块，块内无序，块间有序，即前一块中的最大值小于后一块中的最小值。并且有一张索引表，每一项存放每一块的最大值和指向该块第一个元素的指针。索引表有序，块内无序。所以，块间查找用二分查找，块内用顺序查找，效率介于顺序和二分之间；先确定待查记录所在块，再在块内查找。因此跟表中元素个数和块中元素个数都有关。 用数组存放待查记录, 建立索引表，由每块中最大（小）的关键字及所属块位置的信息组成。 当索引表较大时，可以采用二分查找 在数据量极大时，索引可能很多，可考虑建立索引表的索引，即二级索引，原则上索引不超过三级 分块查找平均查找长度：ASL**bs = L**b + L**w。其中，L**b是查找索引表确定所在块的平均查找长度， L**w是在块中查找元素的平均查找长度。在n一定时，可以通过选择s使ASL尽可能小。当s=sqrt(n)时，ASL最小。 时间：顺序查找最差，二分最好，分块介于两者之间 空间：分块最大，需要增加索引数据的空间 顺序查找对表没有特殊要求 分块时数据块之间在物理上可不连续。所以可以达到插入、删除数据只涉及对应的块；另外，增加了索引的维护。 二分查找要求表有序，所以若表的元素的插入与删除很频繁，维持表有序的工作量极大。 在表不大时，一般直接使用顺序查找。 动态查找二叉排序树的结点删除： x为叶子结点，则直接删除 x只有左子树xL或只有右子树xR ,则令xL或xR直接成为双亲结点f的子树； x即有左子树xL也有右子树xR，在xL中选值最大的代替x，该数据按二叉排序树的性质应在最右边。 平衡二叉树：每个结点的平衡因子都为 1、－1、0 的二叉排序树。或者说每个结点的左右子树的高度最多差1的二叉排序树。 平衡二叉树的平衡： 左调整(新结点插入在左子树上的调整)： LL(插入在结点左子树的左子树上)：旋转前后高度都为h+1 LR(新插入结点在左子树的右子树上)：旋转前后高度仍为h+1 右调整(新结点插入在右子树上进行的调整): RR(插入在的右子树的右子树上)：处理方法和 LL对称 RL(插入在的右子树的左子树上)：处理方法和 LR对称 平衡树建立方法： 按二叉排序树插入结点 如引起结点平衡因子变为|2|，则确定旋转点，该点是离根最远（或最接近于叶子的点） 确定平衡类型后进行平衡处理，平衡后以平衡点为根的子树高不变 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。 常见的平衡二叉树： 红黑树是平衡二叉树，也就是左右子树是平衡的，高度大概相等。这种情况等价于一块完全二叉树的高度，查找的时间复杂度是树的高度，为logn，插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn) 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有简单路径 都包含相同数目的黑色节点。 avl树也是自平衡二叉树；红黑树和AVL树查找、插入、删除的时间复杂度相同；包含n个内部结点的红黑树的高度是o(logn); TreeMap 是一个红黑树的实现，能保证插入的值保证排序 STL和linux多使用红黑树作为平衡树的实现： 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。 map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。 查找总结 既希望较快的查找又便于线性表动态变化的查找方法是哈希法查找。二叉排序树查找，最优二叉树查找，键树查找，哈希法查找是动态查找。分块、顺序、折半、索引顺序查找均为静态。分块法应该是将整个线性表分成若干块进行保存，若动态变化则可以添加在表的尾部（非顺序结构），时间复杂度是O(1)，查找复杂度为O(n)；若每个表内部为顺序结构，则可用二分法将查找时间复杂度降至O(logn)，但同时动态变化复杂度则变成O(n)；顺序法是挨个查找，这种方法最容易实现，不过查找时间复杂度都是O(n)，动态变化时可将保存值放入线性表尾部，则时间复杂度为O(1)；二分法是基于顺序表的一种查找方式，时间复杂度为O(logn)；通过哈希函数将值转化成存放该值的目标地址，O（1） 二叉树的平均查找长度为O(log2n)——O(n).二叉排序树的查找效率与二叉树的高度有关，高度越低，查找效率越高。二叉树的查找成功的平均查找长度ASL不超过二叉树的高度。二叉树的高度与二叉树的形态有关，n个节点的完全二叉树高度最小，高度为[log2n]+1,n个节点的单只二叉树的高度最大，高度为n，此时查找成功的ASL为最大(n+1)/2，因此二叉树的高度范围为[log2n]+1——n. 链式存储不能随机访问，必须是顺序存储 第八章 排序 内部排序：全部数据可同时放入内存进行的排序。 外部排序：文件中数据太多，无法全部调入内存进行的排序。 插入类： 直接插入排序。最坏情况是数据递减序，数据比较和移动量最大，达到O(n2)，最好是数据是递增序，比较和移动最少为O(n)。趟数是固定的n-1，即使有序，也要依次从第二个元素开始。排序趟数不等于时间复杂度。 折半插入排序 。由于插入第i个元素到r[1]到r[i-1]之间时，前i个数据是有序的，所以可以用折半查找确定插入位置，然后插入。 希尔排序。缩小增量排序。5-3-1。在实际应用中，步长的选取可简化为开始为表长n的一半（n/2），以后每次减半，最后为1。插入的改进，最后一趟已基本有序，比较次数和移动次数相比直接插入最后一趟更少 交换类： 冒泡排序。O(n 2 )通常认为冒泡是比较差的，可以加些改进，比如在一趟中无数据的交换，则结束等措施。 在数据已基本有序时，冒泡是一个较好的方法 在数据量较少时（15个左右）可以用冒泡 快速排序。 时间复杂度。最好情况：每次支点总在中间，O(nlog2n)，平均O(nlog2n)。最坏，数据已是递增或递减，O(n2)。pivotkey的选择越靠近中央，即左右两个子序列长度越接近，排序速度越快。越无序越快。 空间复杂度。需栈空间以实现递归，最坏情况：S(n)=O(n)；一般情况：S(n)=O(log2n) 在序列已是有序的情况下，时间复杂度最高。原因：支点选择不当。改进：随机选取支点或最左、最右、中间三个元素中的值处于中间的作为支点，通常可以避免最坏情况。所以，快速排序在表已基本有序的情况下不合适。 在序列长度已较短时，采用直接插入排序、起泡排序等排序方法。序列的个数通常取10左右。 选择类排序： 简单选择排序。O(n2)。总比较次数n(n-1)/2。 堆排序。建堆 O(n)，筛选排序O(nlogn)。找出若干个数中最大/最小的前K个数，用堆排序是最好。小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于[n/2]。时间复杂度不会因为待排序序列的有序程度而改变，但是待排序序列的有序程度会影响比较次数。 归并排序。时间：与表长成正比，若一个表表长是m，另一个是n，则时间是O(m+n)。单独一个数组归并，时间：O(nlogn)，空间：O(n)，比较次数介于(nlogn)/2和(nlogn)-n+1，赋值操作的次数是(2nlogn)。归并排序算法比较占用内存，但却是效率高且稳定的排序算法。在外排序中使用。归并的趟数是logn。 基数排序。在一般情况下，每个结点有 d 位关键字，必须执行 t = d次分配和收集操作。分配的代价：O(n)；收集的代价：O(rd) （rd是基数）；总的代价为：O( d ×(n + rd))。适用于以数字和字符串为关键字的情况。 枚举排序，通常也被叫做秩排序，比较计数排序。对每一个要排序的元素，统计小于它的所有元素的个数，从而得到该元素在整个序列中的位置，时间复杂度为O(n2) 比较法分类的下界：O(nlogn) 排序算法的一些特点： 堆排序、冒泡排序、快速排序在每趟排序过程中,都会有一个元素被放置在其最终的位置上。 有字符序列 ｛Q,H,C,Y,P,A,M,S,R,D,F,X｝ ,新序列{F,H,C,D,P,A,M,Q,R,S,Y,X}，是快速排序算法一趟扫描的结果。(拿Q作为分割点,快速排序一轮。二路归并，第一趟排序，得到 n / 2 个长度为 2 的各自有序的子序列，第二趟排序，得到 n / 4 个长度为 4 的各自有序的子序列H Q C Y A P M S D R F X。如果是快速排序的话，第一个元素t将会被放到一个最准确的位置，t前的数均小于t，后面的数均大于t。希尔排序每个小分组内将会是有序的。堆排序，把它构成一颗二叉树的时候，该堆要么就是大根堆，要么就是小根堆，第一趟Y排在最后；冒泡，那么肯定会有数据下沉的动作，第一趟有A在第一位。) 在文件”局部有序”或文件长度较小的情况下,最佳内部排序的方法是直接插入排序。（归并排序要求待排序列已经部分有序，而部分有序的含义是待排序列由若干有序的子序列组成，即每个子序列必须有序，并且其时间复杂度为O(nlog2n)；直接插入排序在待排序列基本有序时，每趟的比较次数大为降低，即n-1趟比较的时间复杂度由O(n^2)降至O(n)。在待排序的元素序列基本有序或者每个元素距其最终位置不远也可用插入排序，效率最高的排序方法是插入排序） 排序趟数与序列的原始状态有关的排序方法是优化冒泡和快速排序法。(插入排序和选择排序不管序列的原始状态是什么都要执行n-1趟，优化冒泡和快排不一定。仔细理解排序的次数和比较次数的区别) 不稳定的排序方法：快排，堆排，希尔，选择 要与关键字的初始排列次序无关,那么就是最好、最坏、一般的情况下排序时间复杂度不变, 总共有堆排序,归并排序,选择排序,基数排序 快速排序、Shell 排序、归并排序、直接插入排序的关键码比较次数与记录的初始排列有关。折半插入排序、选择排序无关。(直接插入排序在完全有序的情况下每个元素只需要与他左边的元素比较一次就可以确定他最终的位置；折半插入排序，比较次数是固定的，与初始排序无关；快速排序，初始排序不影响每次划分时的比较次数，都要比较n次，但是初始排序会影响划分次数，所以会影响总的比较次数，但快排平均比较次数最小；归并排序在归并的时候，如果右路最小值比左路最大值还大，那么只需要比较n次，如果右路每个元素分别比左路对应位置的元素大，那么需要比较2*n-1次，所以与初始排序有关) 精俭排序，即一对数字不进行两次和两次以上的比较，插入和归并是“精俭排序”。插入排序，前面是有序的，后面的每一个元素与前面有序的元素比较，比较过的就是有序的了，不会再比较一次。归并每次合并后，内部都是有序的，内部的元素之间不用再比较。选择排序，每次在后面的元素中找到最小的，找最小元素的过程是在没有排好序的那部分进行，所有肯定会比较多次。堆排序也需比较多次。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学建模]]></title>
    <url>%2F2019%2F07%2F11%2FMatlab%2F</url>
    <content type="text"><![CDATA[数学建模 一、 Matlab入门matlab下载可以关注一个微信公众号”软件管家“ 1、命令行操作 clc清理命令行窗口/clear清除所有变量 上方向键可以调用之前命令 ；可以抑制输出 多行注释Ctrl+R，取消注释Ctrl+T 2、matlab内置函数和常量 圆周率pi 正余弦函数 sin/cos abs取绝对值 sqrt求平方根 输出和输入函数（disp和input） 数字转字符串：num2str sum函数： 向量，直接求和 矩阵，sum(X,1) =&gt; 按列求和 sum(X,2) =&gt; 按行求和 3、所有 MATLAB 变量都是数组，这意味着每个变量均可以包含多个元素。x = [3 4]表示行向量 y= [3;4]表示列向量 4、创建等间距向量 : 运算符并仅指定起始值和最终值 默认间隔是1，但可以设置间隔frist：dx：last 设置所需元素个数 linspace(first,last,number_of_elements)。注意，请使用逗号 (,) 分隔 linspace 函数的输入。 转置运算符 (&#39;) 将行向量转换为列向量。 5、矩阵创建函数 rand(2，3) 随机创建一个2x3矩阵 zeros() 创建全零矩阵 matlab存储矩阵是按列来存储的 6、保存和加载变量 save 文件名 变量名 load 文件名 提取数组元素：x=A(rows , cols); 当里面是单个索引值时，表示数组顺序存储中第几个 冒号运算符(:)可指代该维度中的所有元素。 x=（1：3，：）表示矩阵1到3行所有元素 关键字end表示该维度的最后一个 matalab支持线性代数中运算形式 矩阵乘法：. 运算符执行按元素乘法，允许您将两个大小相同的数组的对应元素相乘。 7、从函数调用中获取多个输出方括号（[]）可获输出 x= ​ 1 2 ​ 3 4 size函数：s=size(x) ==&gt;s = 2 x 2 ​ [row,col]=size(x) ==&gt;row=2 col=2 ​ r = size(A,1) c=size(A,2) max函数：[xMax,index]=max(x) ==&gt;xMax=4 index=4 当发现不认识的函数时，我们可以使用doc funName查看函数说明 8、绘制向量图plot函数在一张图上绘制两个相同长度的向量。 1&gt;&gt; plot(X,Y) 绘制(x,y)的折线 1&gt;&gt; plot(x,y,'r--o') 以上命令将会绘制一条红色 (r) 虚线 (–)，并使用圆圈 (o)标记 使用 plot函数时，您可在绘图参数和线条设定符之后添加属性名称-属性值对组。 1&gt;&gt; plot(x,y,'ro-','LineWidth',5) 后面的附加参数表示线条设定 hold on 表示保留之前的绘图，可以在它的基础上加图 hold off 表示返回默认绘图方式 close all 表示关闭所有的绘图窗口 绘图注释 xlabel/ylabel函数 设置x，y轴的说明 title函数 设置图的标题 legend（‘label’）指定图例 9、逻辑索引使用逻辑数组作为逻辑索引，MATLAB会提取索引为1的数组元素。 决策分支 if 条件 ​ Statement; else ​ OtherStatement; end 123456789switch switch_expression case case_expression statements case case_expression statements ... otherwise statementsend 10、实时脚本以上语法练习脚本文件 11、导入EXCEL数据入（1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X （2）在Excel中复制数据，再回到Excel中右键，点击粘贴Excel数据（Ctrl+Shift+V）（3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）（4）注意，代码和数据要放在同一个目录下哦。 12、函数function [输出变量] = 函数名称(输入变量）函数的中间部分都是函数体函数的最后要用end结尾输出变量和输入变量可以有多个，用逗号隔开 12345function [a,b,c]=test(d,e,f) a=d+e; b=e+f; c=f+d;end 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同） 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同） 二、数学建模算法与模型 2.1 评价类模型2.1.1 层次分析法（Matlab实现）层次分析法用途： 百度层次分析法说明 确定指标权重，没数据，层次分析法，有数据，bp神经网络 层次分析法是为了对某些事情由于一些相互关联、相互制约的因素而缺乏定量数据的决策问题做出合理解决的办法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091%% 输入判断矩阵clear;clcdisp('请输入判断矩阵A： ')% A = input('判断矩阵A=')A =[1 1 4 1/3 3; 1 1 4 1/3 3; 1/4 1/4 1 1/3 1/2; 3 3 3 1 3; 1/3 1/3 2 1/3 1]% matlab矩阵有两种写法，可以直接写到一行:% [1 1 4 1/3 3;1 1 4 1/3 3;1/4 1/4 1 1/3 1/2;3 3 3 1 3;1/3 1/3 2 1/3 1]% 也可以写成多行:[1 1 4 1/3 3; 1 1 4 1/3 3; 1/4 1/4 1 1/3 1/2; 3 3 3 1 3; 1/3 1/3 2 1/3 1]% 两行之间以分号结尾（最后一行的分号可加可不加），同行元素之间以空格（或者逗号）分开。%% 方法1：算术平均法求权重% 第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）Sum_A = sum(A)[n,n] = size(A) % 也可以写成n = size(A,1)% 因为我们的判断矩阵A是一个方阵，所以这里的r和c相同，我们可以就用同一个字母n表示SUM_A = repmat(Sum_A,n,1) %repeat matrix的缩写% 另外一种替代的方法如下： SUM_A = []; for i = 1:n %循环哦，这一行后面不能加冒号（和Python不同），这里表示循环n次 SUM_A = [SUM_A; Sum_A] endclc;ASUM_AStand_A = A ./ SUM_A% 这里我们直接将两个矩阵对应的元素相除即可% 第二步：将归一化的各列相加(按行求和)sum(Stand_A,2)% 第三步：将相加后得到的向量中每个元素除以n即可得到权重向量disp('算术平均法求权重的结果为：');disp(sum(Stand_A,2) / n)% 首先对标准化后的矩阵按照行求和，得到一个列向量% 然后再将这个列向量的每个元素同时除以n即可（注意这里也可以用./哦）%% 方法2：几何平均法求权重% 第一步：将A的元素按照行相乘得到一个新的列向量clc;APrduct_A = prod(A,2)% prod函数和max函数类似，一个用于乘，一个用于加 dim = 2 维度是行% 第二步：将新的向量的每个分量开n次方Prduct_n_A = Prduct_A .^ (1/n)% 这里对每个元素进行乘方操作，因此要加.号哦。 ^符号表示乘方哦 这里是开n次方，所以我们等价求1/n次方% 第三步：对该列向量进行归一化即可得到权重向量% 将这个列向量中的每一个元素除以这一个向量的和即可disp('几何平均法求权重的结果为：');disp(Prduct_n_A ./ sum(Prduct_n_A))%% 方法3：特征值法求权重% 第一步：求出矩阵A的最大特征值以及其对应的特征向量clc[V,D] = eig(A) %V是特征向量, D是由特征值构成的对角矩阵（除了对角线元素外，其余位置元素全为0）Max_eig = max(max(D)) %也可以写成max(D(:))哦~% 那么怎么找到最大特征值所在的位置了？ 需要用到find函数，它可以用来返回向量或者矩阵中不为0的元素的位置索引。% 那么问题来了，我们要得到最大特征值的位置，就需要将包含所有特征值的这个对角矩阵D中，不等于最大特征值的位置全变为0% 这时候可以用到矩阵与常数的大小判断运算D == Max_eig[r,c] = find(D == Max_eig , 1)% 找到D中第一个与最大特征值相等的元素的位置，记录它的行和列。% 第二步：对求出的特征向量进行归一化即可得到我们的权重V(:,c)disp('特征值法求权重的结果为：');disp( V(:,c) ./ sum(V(:,c)) )% 我们先根据上面找到的最大特征值的列数c找到对应的特征向量，然后再进行标准化。%% 计算一致性比例CRclcCI = (Max_eig - n) / (n-1);RI=[0 0 0.52 0.89 1.12 1.26 1.36 1.41 1.46 1.49 1.52 1.54 1.56 1.58 1.59]; %注意哦，这里的RI最多支持 n = 15CR=CI/RI(n);disp('一致性指标CI=');disp(CI);disp('一致性比例CR=');disp(CR);if CR&lt;0.10 disp('因为CR &lt; 0.10，所以该判断矩阵A的一致性可以接受!');else disp('注意：CR &gt;= 0.10，因此该判断矩阵A需要进行修改!');end 2.1.2 TOPSIS（优劣解距离法） 原理 其基本原理，是通过检测评价对象与最优解、最劣解的距离来进行排序，若评价对象最靠近最优解同时又最远离最劣解，则为最好；否则不为最优。其中最优解的各指标值都达到各评价指标的最优值。最劣解的各指标值都达到各评价指标的最差值。 能充分利用原始数据的信息，其结果能精确地反映各评价方案之间的差距。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849% 第一步：导入数据clear;clcload data_water_quality.mat% 第二步：正向化[m,n] = size(X);% 字符串拼接disp(['共有' num2str(m) '个评价对象, ' num2str(n) '个评价指标']) Judge = input(['这' num2str(n) '个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0： ']);if Judge==1 Position = input('请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： '); %[2,3,4] disp('请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） ') Type = input('例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]： '); %[2,1,3] % 注意，Position和Type是两个同维度的行向量 for i = 1 : size(Position,2) %这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数 X(:,Position(i)) = Positivization(X(:,Position(i)),Type(i),Position(i)); end disp('正向化后的矩阵 X = ') disp(X)end% 让用户判断是否需要增加权重disp("请输入是否需要增加权重向量，需要输入1，不需要输入0")Judge = input('请输入是否需要增加权重： ');if Judge==1 weigh = input(['你需要输入' num2str(m) '个权数。' '请以行向量的形式输入这' num2str(m) '个权重: ']); OK = 0; % 用来判断用户的输入格式是否正确 while OK==0 if sum(weigh)==1&amp;&amp;size(weigh,1)==1&amp;&amp;size(weigh)==n OK=1; else weigh=input('Input Error,Please Go on:') end endelse weigh=ones(1,n);end% 第三步：标准化Z=X./repmat(sum(X*X),n,1);disp('输出标准化矩阵:')disp(Z)% 第四步：归一化并排序D_P = sum([(Z - repmat(max(Z),n,1)) .^ 2 ].*weigh,2) .^ 0.5; % D+ 与最大值的距离向量D_N = sum([(Z - repmat(min(Z),n,1)) .^ 2 ].*weigh,2) .^ 0.5; % D- 与最小值的距离向量S = D_N ./ (D_P+D_N); % 未归一化的得分disp('最后的得分为：')stand_S = S / sum(S)[sorted_S,index] = sort(stand_S ,'descend') 2.2 插值与拟合模型插值：求过已知有限个数据点的近似函数。拟合：已知有限个数据点，求近似函数，可不过已知数据点，只要求在某种意义下它在这些点上的总偏差最小。插值和拟合都是要根据一组数据构造一个函数作为近似，由于近似的要求不同，二者的数学方法上是完全不同的。而面对一个实际问题，究竟应该用插值还是拟合，有时容易确定，有时则并不明显。 2.2.1 插值法推荐查看优秀博文： 插值和拟合 MATLAB回归、插值、逼近、拟合总结（含代码和图例说明） 文件下载：五种插值法的对比研究 1234567891011121314151617181920212223242526272829303132333435363738394041%分段三次皮埃尔插值法clear;clcx = -pi:pi; y = sin(x); new_x = -pi:0.1:pi; p = pchip(x,y,new_x); % 通过matlab内部函数pchip得到插值所得的y值figure(1) %如果不指示，后面的图形则会覆盖掉前面的plot(x,y,'r*',new_x,p,'b-')%% 三次样条插值和分段三次埃尔米特插值的对比x = -pi:pi; y = sin(x); new_x = -pi:0.1:pi;p1 = pchip(x,y,new_x); %分段三次埃尔米特插值p2 = spline(x,y,new_x); %三次样条插值figure(2);plot(x,y,'o',new_x,p1,'r-',new_x,p2,'b-')legend('样本点','三次埃尔米特插值','三次样条插值','Location','SouthEast') %标注显示在东南方向%legend函数说明：%lengend（‘str'与图例顺序相对应，’Location，指示图例说明在figure位置）% n维数据的插值x = -pi:pi; y = sin(x); new_x = -pi:0.1:pi;p = interpn (x, y, new_x, 'spline');% 等价于 p = spline(x, y, new_x);figure(3);plot(x, y, 'o', new_x, p, 'r-')%% 人口预测population=[133126,133770,134413,135069,135738,136427,137122,137866,138639, 139538];year = 2009:2018;% hermite插值是用一条曲线来逼近,最高次数可能高于三次% 三次样条插值是用连续的曲线来逼近,最高次数是三次p1 = pchip(year, population, 2019:2021) %分段三次埃尔米特插值预测p2 = spline(year, population, 2019:2021) %三次样条插值预测figure(4);plot(year, population,'go',2019:2021,p1,'r*-',2019:2021,p2,'bx-')legend('样本点','三次埃尔米特插值预测','三次样条插值预测','Location','SouthEast') 123456789101112131415161718192021222324252627282930313233% 水池补充clear;clc%插值预测中间周的水体评价指标Z=[0,3,5,7,9,11,13,15;1913,1945,1920,2205,2260,2302,2385,2420; 5.12,3.2,6.72,3.36,2.4,4.14,6.43,4.6; 21.9,20,26.8,27.73,23.4,22.75,25.36,26.03; 24.8,25.7,26.8,28,30.4,30,27.6,30.8; 9.31,9.14,9.14,9.29,9.22,9.33,9.16,9.26;1.8,2.3,1.9,2.1,2.1,1.1,1.5,1.5; 28,24,26,22,22,20,19,23; 425.11,457.99,492.48,492.08,501.93,598.48,604.44,623.89; 628.1,639.2,648.87,640.33,616.43,614.72,507.14,580;2 8,24,26,22,22,20,19,23; 30.58,36.19,49.750,60.58,56.58,60.06,67.99,67.74];x=Z(1,:); %Z的第一行是星期Z: 1 3 5 7 9 11 13 15[n,m]=size(Z);%n为Z的行数，m为Z的列数% 注意Matlab的数组中不能保存字符串，如果要生成字符串数组，就需要使用元胞数组，其用大括号&#123;&#125;定义和引用ylab=&#123;'周数','轮虫','溶氧','COD','水温','PH值','盐度','透明度','总碱度','氯离子','透明度','生物量'&#125;; % 等会要画的图形的标签disp(['共有' num2str(n-1) '个指标要进行插值。'])disp('正在对一号池三次埃尔米特插值，请等待')%一号池共有十一组要插值的数据，算上星期所在的第一行，共十二行P=zeros(11,15);%对要储存数据的矩阵P赋予初值for i=2:n%从第二行开始都是要进行插值的指标 y=Z(i,:);%将每一行依次赋值给y new_x=1:15;%要进行插值的x p1=pchip(x,y,new_x);%调用三次埃尔米特插值函数 subplot(4,3,i-1);%将所有图依次变现在4*3的一幅大图上 plot(x,y,'ro',new_x,p1,'-');%画出每次循环处理后的图像 axis([0 15,-inf,inf]) %设置坐标轴的范围，这里设置横坐标轴0-15，纵坐标不变化 % xlabel('星期')%x轴标题 ylabel(ylab&#123;i&#125;)%y轴标题 这里是直接引用元胞数组中的字符串哦 P(i-1,:)=p1;%将每次插值之后的结果保存在P矩阵中 end legend('原始数据','三次埃尔米特插值数据','Location','SouthEast')%加上标注，注意要手动在图中拖动标注到图片右下角哦P = [1:15; P] %把P的第一行加上周数 2.2.2 拟合拟合与插值方法（给出一批数据点，确定满足特定要求的曲线或者曲面，从而反映对象整体的变化趋势）： matlab可以实现一元函数，包括多项式和非线性函数的拟合以及多元函数的拟合，即回归分析，从而确定函数； 同时也可以用matlab实现分段线性、多项式、样条以及多维插值。 拟合：拟合的实现分为MATLAB和excel实现。 MATLAB的实现就是polyfit函数：主要是多项式拟合。 更复杂的函数拟合，使用的是最小二乘法，或者其他方法。但是需要经验公式（通过散点图分析得到经验公式）. 例如：用最小二乘法求一个形如的经验公式，使它与下表所示的数据拟合 matlab代码实现： 1234567x=[19 25 31 38 44]';y=[19.0 32.3 49.0 73.3 97.8]';r=[ones(size(x,1),1),x.^2];ab =r\yx0=19:0.1:44y0=ab(1)+ab(2)*x0.^2;plot(x,y,'o',x0,y0,'r') polyfit - 多项式曲线拟合 此 MATLAB 函数 返回阶数为 n 的多项式 p(x) 的系数，该阶数是 y 中数据的最佳拟合（在最小二乘方式中）。p 中的系数按降幂排列，p 的长度为n+1 p = polyfit(x,y,n)[p,S] = polyfit(x,y,n)[p,S,mu] = polyfit(x,y,n) polyval - 多项式计算 此 MATLAB 函数 计算多项式 p 在 x 的每个点处的值。参数 p 是长度为 n+1 的向量，其元素是 n 次多项式的系数（降幂排序）： y = polyval(p,x)[y,delta] = polyval(p,x,S)y = polyval(p,x,[],mu)[y,delta] = polyval(p,x,S,mu) 2.3 相关性分析相关分析是研究两个或两个以上处于同等地位的随机变量间的相关关系的统计分析方法。例如，人的身高和体重之间；空气中的相对湿度与降雨量之间的相关关系都是相关分析研究的问题，但是要有一定的实际意义才行。 两个变量之间的相关程度通过相关系数r来表示。 SPSS双变量相关性分析与回归分析操作步骤 相关分析与回归分析之间的区别：回归分析侧重于研究随机变量间的依赖关系，以便用一个变量去预测另一个变量;相关分析侧重于发现随机变量间的种种相关特性。相关分析在工农业、水文、气象、社会经济和生物学等方面都有应用。 偏相关性分析：某一个要素对另一个要素的影响或相关程度时，把其他要素的影响视为常数，即暂不考虑其他要素的影响，而单独研究那两个要素之间的 相互关系的密切程度时，称为偏相关。 零阶偏相关分析是指没有控制变量的相关分析，即一般的相关分析。一阶偏相关分析是指有一个控制变量的相关分析，二阶偏相关分析是指有两个控制变量的偏相关分析，其他高阶偏相关分析以此类推。 参考博文链接: 2018数学建模国赛经验帖 历年国赛优秀论文]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习（三）]]></title>
    <url>%2F2019%2F06%2F27%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树 第六章 树树的基本概念树（Tree）是n（n&gt;=0）个结点的有限集。 在任意一棵非空树中： （1）有且仅有一个特定的称为根（Root）的结点； （2）当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1，T2，…，Tn，其中每个集合本身又是一棵树，并称为根的子树（SubTree） 层次 树 1 A ​ / | \ 2 B C D ​ / \ | / | \ 3 E F G H I J ​ / \ | 4 K L M ★树的结点包含一个数据元素及若干指向其子树的分支。 （1）度 结点拥有的子树树称为结点的度（Degree）如：上图A的度为3，C的度为1，F的度为0。 度为0的结点称为叶子（Leaf）或终端结点，如：上图K,L,F,G,M,I,J都是树的叶子 度不为0的结点称为非终端结点或分支结点，如：上图A,B,C,D,E,H ★树的度是树内各节点的度的最大值，如：上图的树的度为 3 。 （2）结点（家谱图） 结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）如：上图D是A的孩子，A是D的双亲。 同一个双亲的孩子叫兄弟（Sibling）如：上图H,I,J为互为兄弟 其双亲在同一层的结点互为堂兄弟。如上图G与E、F、H、I、J互为堂兄弟 结点的祖先是从根到该结点所经分支上的所有结点。如：上图M的祖先为A、D、H （3）层次，深度（你家几代同堂啊？） 结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层， 树中结点的最大层次成为树的深度（Depth）或高度。如：上图树的深度为4 （4）有序树与无序树（长子，次子。。） 树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则成为无序树。 有序树中最左的子树的根称为第一个孩子，最右边的称为最后一个孩子。（毕竟有序，排好了谁是老大，谁是老二，长兄有序嘛） ★森林（Forest）是m（m&gt;=0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。 由此也可以森林和树相互递归的定义来描述树。 二叉树1、二叉树的定义及其主要特征 二叉树（Binary Tree）是另一种树形结构， ★二叉树的特点是： （1）每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点）， （2）二叉树的子树有左右之分，其次序不能随意颠倒。 二叉树要么为空，要么是由一个根结点加上两棵分别称为左子树和右子树的，互不相交的二叉树组成。 ★二叉树的五种形态 ​ | | A | A | A Φ | A | B | B C | B （1） | （2） | （3） | （4） | （5） ★二叉树的性质 （性质一）在二叉树的第 i 层上至多有 2^(i-1)^个结点 （i &gt;=1） ​ （性质二）深度为 k 的二叉树至多有2^k^ -1个结点（k&gt;=1）,至少k个结点。 ​ （性质三）★对任何一棵二叉树 T ，如果其终端结点数位n0，度为2的结点数位n2，则n0=n2+1。 ​ 式一： n = n0 + n1 + n2 （结点总数 等于 度为0 加 度为1 加 度为2） ​ 式二： n = n0 + 2*n2 +1（n = 分支总数+1 ；分支总数 = n1+n2 （分支是由度为1，度为2的结点射出的）） ​ 式二 - 式一得： n0 = n2 + 1 ★完全二叉树 一棵深度为 k 且有2^k^ - 1个结点的二叉树为满二叉树 深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中1到n的结点一 一对应时，称之为完全二叉树 （性质一）具有n个结点的完全二叉树的深度为 」 log 2 n」+1 ​ （性质二） 【通俗版】从下往上看：结点1是根，没双亲；其他点的双亲是 i / 2 取下值 ​ 上往下看：左孩子 是根节点的两倍（偶数），右孩子是根节点的两倍+1（奇数） 二叉树的三种遍历 （先序、中序、后序）先序：先根后左再右 1234567891011121314151617181920212223242526272829Status Visit(TElemType e)&#123; printf(e); return Ok;&#125;//利用递归算法实现先序遍历Status PreOrderTraverse(BiTree T,Status(* Visit)(TElemType e))&#123; if(T)&#123; if(Visit(T-&gt;data))&#123; if(PreOrderTraverse(T-&gt;lchild,Visit)) if(PreOrderTraverse(T-&gt;rchild,Visit)) return Ok; &#125; retrun ERROR; &#125;else return OK;&#125;//利用非递归算法实现中序遍历Status InOrderTraverse(BiTree Visit())&#123; InitStack(S);p=T; while(p||!StackEmpty(S))&#123; if(p)&#123;Push(S,p); p=p-&gt;lchild;&#125;//根指针进栈，遍历左子树 else&#123; //根指针退栈，访问根结点，遍历左子树 Pop(S,p); if(!Visit(p-&gt;data))return ERROR; p=p-&gt;rchild; &#125; &#125; return OK;&#125; 最优二叉树（Huffman树）参考链接： 数据结构树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习（二）]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-1%2F</url>
    <content type="text"><![CDATA[栈和队列 第三章 栈和队列一、栈栈（stack）是限定仅在队尾进行插入或删除操作的线性表。 线性表的尾端为栈顶，表头为栈底。 特点：栈是LIFO（Last In First Out），先存进去的数据只能最后被取出来，进出顺序逆序，即先进后出，后进先出。 栈的表示和实现（top、base、为空或满的判断条件、元素个数） 顺序栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 //-------栈的顺序存储表示---------#define STACK_INIT_SIZE 100#define STACKINCREMENT 10typedef int SElemType;typedef struct &#123; SElemType *base; //在栈构造之前和销毁之后，base的值为NULL SElemType *top; //栈顶指针 int stackSize; //当前分配的存储空间&#125;SqStack;//构造一个空栈Status InitStack(SqStack &amp;S)&#123; S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType)); if (!S.base) exit(OVERFLOW); S.top = S.base; S.stackSize = STACK_INIT_SIZE; return OK;&#125;///销毁栈S，S不再存在Status DestroyStack(SqStack &amp;S)&#123; S.stackSize = 0; free(S.base); S.base = S.top = NULL; return OK;&#125;////把S置为空栈Status ClearStack(SqStack &amp;S)&#123; S.top = S.base; return OK;&#125;//判断栈是否为空Status StackEmpty(SqStack &amp;S)&#123; if (S.base == S.top) return TRUE; else return FALSE;&#125;//返回S的元素个数，即栈的长度int StackLength(SqStack S) &#123; return (S.top - S.base);&#125;//获取栈顶元素Status GetTop(SqStack S, SElemType &amp;e)&#123; if (StackEmpty(S))return ERROR; e= *(S.top - 1); return OK;&#125;//压栈Status Push(SqStack &amp;S, SElemType e)&#123; if (S.top - S.base &gt;= S.stackSize)//栈满，追加存储空间 &#123; S.base = (SElemType *)realloc(S.base, (S.stackSize + STACKINCREMENT) * sizeof(SElemType)); if (!S.base) exit(OVERFLOW); S.top = S.base + S.stackSize; //将top指针指向要添加的位置去 S.stackSize += STACKINCREMENT; &#125; *(S.top++) = e; return OK;&#125;//弹栈Status Pop(SqStack &amp;S, SElemType &amp;e)&#123; if (S.base == S.top) return ERROR; e = *(--S.top); return OK;&#125;//遍历栈void visit(SElemType a) &#123; printf("%d\n", a);&#125;Status StackTraverse(SqStack S, void(*visit)(SElemType))&#123; printf("Stack Traverse: \n"); SElemType *p = S.base; while (p != S.top) &#123; visit(*p++); &#125; return OK;&#125; 链式栈 1234567891011//------------链式栈的存储结构----------teypedef struct StackNode&#123;ElemType data; // 存放栈的数据StackNode *next;&#125; StackNode, *LinkStackPtr;teypedef struct LinkStack&#123;LinkStackPrt top; // top指针int count; // 栈元素计数器&#125; 栈的相关应用 3.1 数制转换 123456789101112131415161718//对于输入任意的一个非负十进制整数，打印输出与其等值的八进制数void Conversion()&#123; SqStack S; InitStack(S); int e, Num; scanf_s("%d", &amp;Num); while (Num) &#123; Push(S, Num % 8); Num /= 8; &#125; while (!StackEmpty(S)) &#123; Pop(S, e); printf("%d ", e); &#125; printf("\n");&#125; 3.2 括号匹配的检验 12345678910111213141516171819202122232425262728293031323334353637383940414243int Match(char ch, char str) &#123;//检查是否匹配 if (ch == '('&amp;&amp;str == ')') return TRUE; if (ch == '['&amp;&amp;str == ']') return TRUE; if (ch == '&#123;'&amp;&amp;str == '&#125;') return TRUE; return FALSE;&#125;void BracketMatch(char *str) &#123;//str为输入的字符串 char ch; int i = 0; SqStack S; InitStack(S); while (str[i] != '\0') &#123; switch(str[i]) &#123; case '(': case'[': case'&#123;': Push(S, str[i]); break; case')': case']': case'&#125;': if (StackEmpty(S)) &#123; printf("括号不匹配！\n"); return; &#125;else &#123; GetTop(S, ch); if (Match(ch, str[i])) Pop(S, ch); else &#123; printf("括号不匹配！\n"); return; &#125; &#125; &#125; i++; &#125; if (StackEmpty(S)) printf("括号匹配\n"); else printf("括号不匹配！\n");&#125; 3.3 行编辑程序算法实现（部分） 12345678910111213141516171819202122232425//在终端窗口有一新行，没有输入内容，输入Ctrl+D表示EOF//在终端窗口有一新行，有输入内容，按两次Ctrl+D表示EOFvoid LineEdit()// 利用字符栈，从终端接收一行并传送至调用过程的数据区&#123; SqStack S; InitStack(S); char c, ch = getchar(); while (ch != EOF) &#123; while (ch != EOF &amp;&amp; ch != '\n') &#123; switch (ch) &#123; case'#':Pop(S, c); break; //前一个元素输入错误，想要删除 case'@':ClearStack(S); break; //当前错误过多，删除整行 default:Push(S, ch); break; //存入栈 &#125; ch = getchar(); &#125; StackTraverse(S, visit); ClearStack(S); if (ch != EOF) ch = getchar();//如果行没结尾，则直到读到结尾 &#125; DestroyStack(S);&#125; 二、队列队列（queue）是限定仅在表头进行删除，表尾删除操作的线性表。 特点：先进先出（FIFO） 循环队列（front、rear、为空或满的判断条件、元素个数） 与顺序栈类似，在队列的顺序结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个指针front和rear分别指示队列头元素及队列尾元素的位置。 用此方法表示循环队列，就无法用Q.front=Q.rear来判断队列空间是空还是满。可有两种处理方法：其一是另设一个标志位以区别队列是空还是满；其二是少用一个元素空间，约定以“队列头指针在队列尾指针的下一位置上”作为队列呈满状态的标志。 从上述分析可见，C语言中不能用动态分配的一维数组来实现循环队列。如果要用，就必须为它设定一个最大队列长度；若无法预估所用队列的最大长度，建议使用链队列。 描述： 1234初始化建空队列时，令front=rear=0每当插入新的队尾元素时，“尾指针+1；每当删除队列头元素时，“头指针-1”；因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940#define MAXSIZE 100 //最大队列长度typedef struct &#123; int *base;//初始化的动态分配储存空间，int可以换成元素的类型 int front; int rear; //队尾 //非链式，应该是顺序存储&#125;SqQueue;//---------------------循环队列的基本操作的算法描述bool InitQueue(SqQueue &amp;Q) &#123; //构造一个空队列Q Q.base = (int *)malloc(MAXSIZE * sizeof(int)); if (!Q.base)exit(OVERFLOW); Q.front = Q.rear=0; return 1;&#125;int QueueLength(SqQueue &amp;Q)&#123; //返回Q的元素个数，即队列长度 return((Q.rear - Q.front + MAXSIZE) % MAXSIZE);&#125;bool EnQueue(SqQueue &amp;Q, int e)&#123; //判断条件 if ((Q.rear + 1) % MAXSIZE == Q.front)return 0; Q.base[Q.rear] = e; Q.rear = (Q.rear + 1) % MAXSIZE; return 1;&#125;bool DeQueue(SqQueue &amp;Q,int &amp;e)&#123; //若队列不空，则删除Q的队头元素，用e返回其值 if (Q.front == Q.rear)return 0; e = Q.base[Q.front]; Q.front = (Q.front + 1) % MAXSIZE;//由于下标是动态的，可能对应+1就到了开头的情况 return 1;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习（三）]]></title>
    <url>%2F2019%2F06%2F25%2F%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[串和数组 第四章 串一、串的概念与存储结构串（字符串）：是零个或多个字符 组成的有限序列。 串值：双引号括起来的字符序列是串值。 串长：串中所包含的字符个数称为该串的长度。 空串（空的字符串）：长度为0的串称为空串，不包含任何字符。 空格串（空白串）：构成串的所有字符都是空格的串称为空白串。空串和空白串不同。如“ ”和“”分别表示长度为1 的空白串和长度为0 的空串。 子串：串中任意个连续字符组成的子串称为该串的子串，包含子串的串相应地称为主串。 子串的序号：将子串在主串中首次出现时的该子串的首字符对应主串中的序号，称为子串在主串中的序号(或位置)。 注意：空串是任意串的子串，任意串是其自身的子串。 串相等：如果两个串的串值相同，称为串相等。即串的长度相等，且各个对应位置的字符都相同时才相等。 通常在程序中使用的串可分为两种：串变量和串常量： 二、串的存储表示和实现————两种存储结构：顺序和链式。串的逻辑结构和线性表极为相似，区别仅在与串的数据对象约束为字符集。 在串的基本操作中基本以“串的整体”作为操作对象。 串的链式存储结构和线性表的串的链式存储结构类似，采用单链表来存储串，结点的构成是： data域：存放字符，data域可存放的字符个数称为结点的大小。 next域：存放指向下一个结点的指针。 定长顺序存储表示：用一组地址连续的存储单元来依次存储串中的字符序列。将串定义为字符数组，利用串名可以直接访问串值。此方式，串的存储空间在编译时确定，其大小不能改变。 堆分配存储方式：仍然用一组地址连续的存储单元来依次存储串中的字符序列，但串的存储空间是在程序运行时根据串的实际长度动态分配的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 100//串的顺序存储 typedef struct st&#123; char *ch; //串存放的起始地址，串中第i个字符存储在ch[i-1]中 int length; //串的长度 int strsize; //分配的存储空间的大小，如果不足，在通过realloc()分配增加空间&#125;string; //串的初始化操作string CreateNullString()&#123; string s; s.length = 0; s.ch = (char*)malloc(MAXSIZE *sizeof(char)); s.strsize = MAXSIZE; return s;&#125; //判断空串int isEmpty(string s)&#123; if (s.length == 0) return 1; else return 0;&#125; //赋值操作void StringAssign(string *s1, char s2[])&#123; int i = 0; while (s2[i] != '\0') // '\0' 是字符串的结束符，任何字符串之后都会自动加上'\0' i++; //计算s2的长度 if (i&gt;s1-&gt;strsize)&#123; //所赋值的字符数组超过字符串的默认容量，则增加存储空间 s1-&gt;ch = (char*)malloc(i*sizeof(char)); s1-&gt;strsize = i; &#125; s1-&gt;length = i; for (i = 0; i&lt;s1-&gt;length; i++) s1-&gt;ch[i] = s2[i]; //从第一个字符开始逐个字符赋值&#125; //串拷贝操作void StringCopy(string *s1, string s2)&#123; if (s1-&gt;strsize&lt;s2.length)&#123; //realloc则对malloc申请的内存进行大小的调整. s1-&gt;ch = (char*)realloc(s1-&gt;ch, s2.length*sizeof(char)); s1-&gt;strsize = s2.length; &#125; s1-&gt;length = s2.length; int i; for (i = 0; i&lt;s1-&gt;length; i++) s1-&gt;ch[i] = s2.ch[i];&#125; //求串的长度int StringLength(string s)&#123; return s.length;&#125; //串的连接操作void concat(string *s, string s1, string s2)&#123; if (s-&gt;strsize&lt;s1.length + s2.length)&#123; s-&gt;ch = (char*)realloc(s-&gt;ch, (s1.length + s2.length)*sizeof(char)); s-&gt;strsize = s1.length + s2.length; &#125; s-&gt;length = s1.length + s2.length; //两串连接 int i; for (i = 0; i&lt;s1.length; i++) //将s1复制到s中 s-&gt;ch[i] = s1.ch[i]; for (; i&lt;s-&gt;length; i++) s-&gt;ch[i] = s2.ch[i - s1.length]; //将s2复制到s中去&#125; //取子串操作int substr(string s, int i, int len, string *t)&#123; /* i表示从字符串s的第i个位置开始截取（索引从1开始） len表示截取字符串的长度 */ if (i &lt;= 0 || i&gt;s.length || len&lt;0 || len&gt;s.length - i + 1) //参数不合法 return 0; if (t-&gt;length&lt;len)&#123; //存储空间不够，继续分配存储空间 t-&gt;ch = (char*)realloc(t-&gt;ch, len*sizeof(char)); t-&gt;strsize = len; &#125; t-&gt;length = len; int k; for (k = 0; k&lt;t-&gt;length; k++) t-&gt;ch[k] = s.ch[i - 1 + k]; return 1;&#125; //插入操作int insertString(string *s, int i, string t)&#123; //在字符串s的第i个位置插入字符串t if (i &lt;= 0 || i&gt;s-&gt;length + 1) return 0; if (s-&gt;strsize&lt;s-&gt;length + t.length)&#123; //空间不足 s-&gt;ch = (char*)realloc(s-&gt;ch, (s-&gt;length + t.length)*sizeof(char)); s-&gt;strsize = s-&gt;length + t.length; &#125; int k; for (k = s-&gt;length - 1; k &gt;= i - 1; k--) //将s中的后i个字符后移到后面 s-&gt;ch[k + t.length] = s-&gt;ch[k];//end[][][] ==&gt; e[][][]nd s-&gt;length = s-&gt;length + t.length;//s-&gt;length=3+3 for (k = 0; k&lt;t.length; k++) //将t的值赋值给s s-&gt;ch[k + i - 1] = t.ch[k];//e[][][]nd==&gt;eaaand return 1;&#125; //删除操作int deleteString(string *s, int i, int len)&#123; //从s的第i个字符开始删除len个字符 if (i &lt;= 0 || i&gt;s-&gt;length || len&lt;0 || len&gt;s-&gt;length - i + 1) //参数不合法 return 0; int k; for (k = i + len - 1; k&lt;s-&gt;length; k++) //从s的i+len-1个位置开始将其后的所有字符前移 s-&gt;ch[k - len] = s-&gt;ch[k]; s-&gt;length -= len; return 1;&#125; //输出操作void print(string s)&#123; int i; for (i = 0; i&lt;s.length; i++) printf("%c", s.ch[i]); printf("\n");&#125; int main()&#123; string s1 = CreateNullString(); string s2 = CreateNullString(); string s3 = CreateNullString(); char ch[MAXSIZE]; printf("请输入主串：\n"); //输入friend gets_s(ch); //赋值操作 StringAssign(&amp;s1, ch); printf("主串 s1 为："); print(s1); //将字符s1拷贝到s2 StringCopy(&amp;s2, s1); printf("拷贝串操作结果如下，结果如下 s2 ："); print(s2); printf("删除操作（1——s1.length-3 全删）："); //删除操作 deleteString(&amp;s2, 1, s1.length - 3); print(s2); printf("插入操作,插入到s2的第2个位置上，请输入插入的字符串："); gets_s(ch); //赋值操作 把输入的字符放到s3中 StringAssign(&amp;s3, ch); //进行插入操作,将s3插入到s2的第二个位置上 insertString(&amp;s2, 2, s3); print(s2); printf("取子串操作（取s1的子串【2-4】)："); //提取friend 中[2-4]位置元素-rie substr(s1, 2, 3, &amp;s3); print(s3); //s1==&gt;friend s3==&gt;rie printf("串连接操作【将s1与s3合并】："); concat(&amp;s1, s1, s2); print(s1);&#125; 块链存储方式：是一种链式存储结构表示。 若每个结点仅存放一个字符，则结点的指针域就非常多，造成系统空间的浪费，为节省存储空间，考虑串结构的特殊性，使每个结点存放若干个字符，这种结构称为块链结构。 串模式匹配（Next[j]值求解） KMP模式匹配： 123456789101112int Index_KMP(SString S,SString T,int pos)&#123;//利用模式串T的next函数求T在主串S中第pos个字符位置之后的元素int i =pos,j=1;while(i&lt;S[0]&amp;&amp;j&lt;T[0])&#123; if(j==0||S[i]==T[j])&#123; ++i;++j; //继续比较后继元素 &#125; else j=next[j]; &#125; if(j&gt;T[0])return i-T[0]; else return 0;&#125; 得到next[i]方法： 123456789101112void get_next(SString T, int next[])&#123; int i=1,j=0; next[1]=0; while(i&lt;T[0])&#123; if(j==0||T[i]==T[j])&#123; i++;j++; if(T[i]!=T[j]) next[i]=j; else next[i]=next[j]; &#125; &#125;&#125; 第五章 数组和广义表 1.数组的概念 数组是由n（n&gt;1）个具有相同数据类型的数据元素a1,a2,…,an组成的有序序列，且该序列必须存储在一块地址连续的存储单元中。 数组中的数据元素具有相同数据类型； 数组是随机存取结构，给定一组下标，就可以访问与其对应的数据元素； 数组中的数据元素个数是固定的。 2.数组元素地址的计算 二维数组 a[m][n] 行优先顺序存储：LOC[a~ij~]=LOC[a~00~]+(i*m+j)*sizeof(ElemType) 3.稀疏矩阵的压缩存储（三元组表示法） 对于稀疏矩阵，采用压缩存储方法时，只存储非0元素。必须存储非0元素的行下标值，列下标值、元素值。 一个三元组（i,j,aij）唯一确定稀疏矩阵的一个非零元素。 4.广义表（长度、深度、求表头Head、求表尾Tail操作） 广义表又称列表，是由n个元素组成的有穷序列：LS=(a1,a2,….,an)。其中ai或是原子项，或是一个广义表。LS是广义表的名字，n为长度。若ai是广义表，则称为LS的子表。 习惯上原子用小写字母，子表用大写字母。若广义表LS非空时： a1（表中的第一个元素）称为表头； 其余元素组成的子表称为表尾； 广义表中所包含的元素(包括原子和子表)的个数称为表的长度。 广义表中括号的最大层数称为表深(度)。 广义表本身是一个递归表。即列表本身也可以是自己的一个子表。 根据对表头、表尾的定义，任何一个非空广义表的表头可以是原子，也可以是子表，而表尾必定是广义表。 e.g. A=()——A是空表，长度为0 B=((),(e),(a,b,c))——B长度为3，深度为3 GetHead(B)=() GetTail(B)=((e),(a,b,c)) 注意()和(())不同，前者为空表，长度为0，后者长度为1，表头和表尾均为()]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习（一）]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[线性表 第一章 绪论数据结构是相互之间存在一种或多种特定特定关系的数据元素的集合。 重要术语： 1、数据：对客观事物的符号表示，指所有能输入到计算机中并被计算机程序处理的符号的总称。 2、数据项：数据项是数据的不可分割的最小单位。 3、数据元素：数据的基本单位，在计算机中作为一个整体进行考虑和处理，一个数据元素由多个数据项组成。 4、数据对象：性质相同的数据元素的集合，是数据的一个子集。 数据结构的四种结构： 算法效率度量： 事后统计的方法：对运行结果进行统计分析，得出执行效率。 事前分析估算：估算算法的时间复杂度——算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。 时间复杂度常用大O符号表述，如O(1),O(n),O(n)等，不包括这个函数的低阶项和首项系数。 一般我们最常用的办法是讨论算法在最坏情况下的时间复杂度。 常见的 O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2) 对数据进行操作：初始化、判断是否是空、存取、统计个数、遍历、插入、删除、查找、排序 ————用算法进行描述。 第二章 线性表一、线性表的定义及特性 定义：线性表是具有相同类型的 n（≥0）个数据元素的有限序列 线性表的顺序存储（顺序表）和链式存储（链表） 1.顺序表（SeqList)使用一维数组一次存放书元素。 123456789101112/-------------线性表的动态分配顺序存储结构---------#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量#define LISTINCREMENT 10 //线性表的存储空间的分配增量typedef int ElemType;//额外添加类型名定义// 采用动态分配的顺序存储结构typedef struct &#123; ElemType *elem; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量&#125;SqList; 一维数组占用一块内存空间，每个存储单元的地址是连续的，通过下标识别元素，它的下标就代表了他的存储单元序号，也就表示了它的位置。 查找顺序表中的元素是方便的，根据下标就可以取出要取的元素。 当顺序表的容量不够时，顺序表不能就地扩容，要申请另一个更大容量的数组进行数组元素复制。Java源代码中的ArrayList类扩容实现过程是：先申请增加的容量是原本容量的二分之一，生成一个原本容量的二分之三的内存地址，再将所有元素进行复制过去。 2.线性表的链式存储结构(链表LinkedList)是用若干地址分散的存储单元存储数据元素，逻辑上相邻的数据元素在物理位置上不一定相邻。 存储一个数据元素的存储单元成为结点Node，单链表的表示方式：结点（数据域，地址域）。 12345678//链式存储结构typedef struct Node&#123; int data; struct Node* next;&#125;Node;typedef struct Node* PNode; 二、线性表顺序讯相互及基本操作（插入、删除） 对于插入、删除元素：先根据下标找到相应位置，若插入元素，将新插入插入位置后，将被加入位置的旧元素及之后的元素向后移动，移动次序是由后向前。若删除元素，将要删除的元素删除，其后的元素向前移动。插入和删除的操作时间主要用于移动元素。 123456789101112131415161718192021222324252627282930313233343536373839404142/插入操作,插入一个元素到线性表的第i个位置//1.判断线性表是否已满//2.判断i的位置是否合理//3.从最后一个元素到当前元素后移//4.当前元素插入Status InsertList_Sq(SqList &amp;L, int i, ElemType e)&#123; if (i&lt;1 || i&gt;L.length + 1)return ERROR; ElemType *newBase; if (L.length &gt;= L.listsize) &#123; newBase = (ElemType *)realloc(L.elem, (L.listsize + LISTINCREMENT) * sizeof(ElemType)); if (!newBase)exit(OVERFLOW); L.elem = newBase; L.listsize += LISTINCREMENT;&#125;//前一部分的作用是怕预先分配的内存不够用或者输入值异常所做的处理ElemType* q = &amp;(L.elem[i - 1]);//先将要插入部分之后的元素后移一位for (ElemType *p = &amp;(L.elem[L.length - 1]); p &gt;= q; p--) *(p + 1) = *p; //插入e，并表长加1*q = e;++L.length;return OK;&#125;Status DeleteList_Sq(SqList &amp;L, int i, ElemType &amp;e)&#123; if (i&lt;1 || i&gt;L.length)return ERROR; ElemType* q = &amp;(L.elem[i - 1]); e = *q; for (ElemType *p = &amp;(L.elem[L.length - 1]); p &gt;= q; p--) *(p - 1) = *p; L.length--;return OK;&#125; 三、单链表的操作（插入、删除、查找、归并等） 对于单链表的操作：遍历操作是从第0个结点开始，沿着结点的Next链，依次访问单链表中的每个结点，并且每个节点只访问一次。插入（删除）操作：根据要插入（删除）的结点数，从第0个结点遍历找到要插入（删除）的位置，将要插入的数据元素插入（将要删除的元素删除），改变原来结点间的链接关系，不用移动数据元素。而操作所花的时间都在查找上面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162//初始化链表bool InitList(PNode* pHead)&#123; *pHead = (PNode)malloc(sizeof(Node)); if (!(*pHead))//分配空间失败 &#123; return false; &#125;(*pHead)-&gt;next = NULL;return true;&#125;//创建链表，从头插入void CreateListHead(PNode pHead)&#123; PNode p = pHead; int num, data; printf("清输入要创建的节点个数\n"); scanf_s("%d", &amp;num); for (int i = 0; i &lt; num; i++) &#123; //先新造一个节点 scanf_s("%d", &amp;data); PNode q = (PNode)malloc(sizeof(Node)); (*q).data = data; //将新节点放在头结点后 q-&gt;next = p-&gt;next; p-&gt;next = q; &#125;&#125;//创建链表，从尾插入void CreateListTail(PNode pHead)&#123; PNode p = pHead; int num, data; printf("清输入要创建的节点个数\n"); scanf_s("%d", &amp;num); for (int i = 0; i &lt; num; i++) &#123; scanf_s("%d", &amp;data); PNode q = (PNode)malloc(sizeof(Node)); (*q).data = data; p-&gt;next = q; p = q; &#125; (*p).next = NULL;&#125;//第i个位置插入一个链表节点bool ListInsert(PNode pHead, int i, int val)&#123; int j = 0; PNode p = pHead; PNode q = (PNode)malloc(sizeof(Node)); while (p &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; j++; &#125; if (!p || j &gt; i - 1) &#123; return false; &#125; (*q).data = val; q-&gt;next = p-&gt;next; p-&gt;next = q; return true;&#125;//删除第i个位置的节点bool ListDelete(PNode pHead, int i, int* val)&#123; int j = 0; PNode p = pHead; while (p-&gt;next &amp;&amp; j &lt; i - 1)//注意while(p-&gt;pNext!=NULL&amp;&amp;i&lt;pos-1)与while(p!=NULL&amp;&amp;i&lt;pos-1)的差别，比如链表长度为6，当数大于等于8时有区别 &#123; p = p-&gt;next; j++; &#125;if (!p-&gt;next || j &gt; i - 1)&#123; return false;&#125;PNode q = p-&gt;next;*val = q-&gt;data;p-&gt;next = q-&gt;next;free(q);return true;&#125;//查找算法//类型一：获取链表第i个元素的值bool ListGetElement(PNode pHead, int i, int&amp; val)//val存储返回值&#123; int j = 0; PNode p = pHead; while (p-&gt;next &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; j++; &#125; if (!p-&gt;next || j &gt; i - 1) &#123; return false; &#125; val = p-&gt;next-&gt;data; return true;&#125;//类型二：获取链表元素值val的位置/* 初始条件：顺序线性表L已存在 *//* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 *//* 若这样的数据元素不存在，则返回值为0 */int ListLocateElement(PNode pHead, int val)&#123; PNode p = pHead-&gt;next; int i = 0; while (p) &#123; i++; if (p-&gt;data == val) return i; p = p-&gt;next; &#125; return 0;&#125;//归并void MergeList_L(pNode &amp;La,pNode &amp;Lb,pNode &amp;Lc)&#123; //已知单链线性表La和Lb的元素也按值非递减排列 //归并La和Lb得到新的单链表Lc,Lc的元素也按非递减排列 pNode pa=La-&gt;next; pNode pb=Lb-&gt;next; Lc=La; pNode pc=Lc; while(pa&amp;&amp;pb)&#123; if(pa-&gt;data&lt;=pb-&gt;data)&#123; pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; &#125; else&#123; pc-&gt;next=pb; pc=pb; pb=pb-&gt;next; &#125; &#125; //插入剩余片段,如果pa尾结点不为空，因为之前的循环结束条件是pa和pb中有一个为空，即一个表归并完 (pc-&gt;next=pa)!= NULL ? pa : pb; free(Lb);&#125; 四、双向链表单链表结点中只有一个指向其后继的指针，这使得单链表只能从头到尾依次顺序的向后遍历，若要访问某个结点的前驱，只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)；为克服以上缺点，引入双链表，一个结点含有两个指针，分别指向其前驱结点和后继结点。 1234567891011//------线性表的双向链表存储结构----------typedef struct DuLNode&#123;ElemType data;struct DuLNode *prior; //前驱指针struct DuLNode *next; //后继指针&#125;DuLNode,*DuLinkList; 和单向链表相比有以下优势： 插入删除不需要移动元素外，可以原地插入删除 可以双向遍历 初始化+尾插法图示： 1//head始终指向头结点，p指向尾节点，方便后续算法使用 删除单个图示：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R]]></title>
    <url>%2F2019%2F06%2F04%2FR%2F</url>
    <content type="text"><![CDATA[R语言 一、R的数据结构1、对象和属性赋值：&lt;- 查看数值类型class(x) 属性(attribute) 名称(name) 维度(dimensions: matrix, array) 类型(class) 长度(length) 向量(vector) 只能包含同一类型的对象 创建对象 vector(“type”,length= ) c() x &lt;- 1:4 强制类型转换 as.logical()/as.numeric()/as.character() 矩阵(matrix) 向量+维度属性(整数向量：nrow，ncol) 创建矩阵 matrix(): 先列后行 vector()+dim() 按行/列拼接矩阵 rbind()/cbind() 查看向量属性 attributes() 列表(list) 可以包含不同类型的对象 创建列表 list() 123456# list l &lt;- list("a",2,10L,3+4i,TRUE) l2&lt;-list(a=1,b=2,c=3) l3&lt;- list(c(1,2,3),c(4,5,6,7)) x &lt;- matrix(1:6,nrow = 2,ncol=3) dimnames(x)&lt;-list(c("a","b"),c("e","f","g")) 因子(factor) 分类数据/有序 vs. 无序 整数向量+标签(label)(优于整数向量) Male/Female vs. 1/2 创建因子 factor() 整体查看因子 table() 去除因子属性 unclass() 缺失值(missing value) NA/NaN: NaN属于NA，NA不属于NaN NA有类型属性：integer NA，character NA等。而NaN只有integer 查看元素是否为缺失值 is.na()/is.nan() 数据框(data frame) 存储表格数据 视为各元素长度相同的列表 每个元素代表一列数据 每个元素的长度代表行数 元素的类型可以不同 创建数据框 1df &lt;- data.frame(id=c(1,2),name=c("a","b"),gender=c(TRUE,FALSE)) 日期和时间 日期：Date 当前时间：date()/Sys.Date() weekdays()/months()/quarters() 季度 设置时间 x &lt;- as.Date(“2019-01-01”) 时间：POSIXct/POSIXlt 距离1970-01-01的秒数/Sys.time() POSIXct:整数，常用于存入数据框 POSIXlt:列表，还包含星期、年、月、日等信息 获取某个数组里面的内容用$ 二、构建子集原始数据 -&gt; 预处理后的数据 基本方法 []:提供一个或多个类型相同的元素 元素下标从1开始 枚举输出x[1:4] 逻辑判断x[x5] 按元素名字提取a[“name”] [[]]:从列表或数据框中提取元素 $:按名字从列表或数据框中提取元素 矩阵的子集 以向量形式1行2列的元素 x[1,2] 输出一整行 x[1, ] 输出x(2,3)和x(2,1) x[2,c(1,3)] 以矩阵形式返回 x[1,2,drop=”FALSE”] 数据框的子集 which(x$v1&gt;2)返回满足条件的数值 构建子集 subset(dateType,条件) 列表的子集 x[1]/x[“id”] 列表的元素 x[[1]]/x[[“id”]]/x$id 列表的内容 嵌套列表 x[[1][2]]/x[c(1,2)] 不完全匹配 x[[“a”,exact=FALSE]]/x$a 处理缺省值 返回x,y对应位置是否有缺省值，有返回FALSE complete.cases(x,y) 向量化操作 12345678910111213x &lt;- 1:5y &lt;- 6:10#每个向量对应位置的值做运算x+yx*yx1&lt;-matrix(1:4,nrow=2,ncol=2)y1&lt;-matrix(rep(2,4),nrow = 2,ncol = 2)x1+y1x1/y1x1 %*% y1 三、重要函数的使用1、 lapply()lapply(列表/其他的也会自动转换为列表，循环要处理的函数名，上一个函数所需的参数) 总是返回一个列表 sapply表示在能精简的情况下，尽可能精简处理结果 结果列表元素长度均为1，返回向量 结果列表元素长度相同且大于1，返回矩阵 mean求平均值 2、apply 沿着数组的某一维度处理数据 apply(数组，维度，函数名) 3、tapply 对向量的子集进行操作 tapply (向量，因子/因子列表，函数/函数名) 4、split 根据因子或者因子列表将向量或其他对象分组 通常与lapply一起使用 split(向量/列表/数据框，因子/因子列表) 四、R的绘图系统1)基本绘图系统绘图函数（graphics包） plot/hist/boxplot/pionts/lines/text/title/axis 调用函数会启用一个图形设备（如果没有正在运行的图形设备）并在设备上绘图 基本绘图系统+屏幕设备 plot() 重要参数： xlab/ylab 表示x，y坐标轴标签 lwd 线宽 lty 线的类型 pch 点的类型 col 图形的颜色 par () 用于设置全局参数(作用于R中的所有plot绘图) bg 背景色 mar 边界边距 mfrow 当前画板划分为几行 mfcol 划分为几列 2）Lattice绘图系统1.绘图函数​ lattice包 + xyplot 散点图函数 + histogram 柱状图函数 + dotplot 点图 + contourplot 格式：xyplot(y~x|f*g,data) panel函数，用于控制每个面板内的绘图 grid包 实现了独立于base的绘图系统 lattice包是基于grid创建的 3）Lattice与Base的重要区别​ Base绘图函数直接在图形设备上绘图 ​ Lattice绘图函数返回trellis类对象 ​ 打印函数真正执行了在设备上绘图 4）ggplot2绘图系统 绘图函数 ​ qplot() 类似与Base系统的plot()，参数包含aesthetics/geom/facet… ggplot() 123456789101112131415161718library(ggplot2)qplot(Wind,Temp,data=airquality,color=Month,shape=Month,size=Month ,xlab="Wind(mph)",ylab="Temperature",main="Wind vs. Temp")qplot(Wind,Temp,data=airquality,color=Month,geom=c("point","smooth"))#设置面板属性 ~. Month 表示按月份划分行，1列qplot(Wind,Temp,data=airquality,facets = Month ~.)qplot(Wind,data = airquality,facets = .~ Month)#累加柱状图qplot(Wind,data = airquality,fill=Month)#密度函数qplot(Wind,data = airquality,geom="density",color=Month)qplot(Wind,data = airquality,geom="dotplot",color=Month) 12 图形参数： 符号和线条：pch、cex、lty、lwd 颜色：col、col.axis、col.lab、col.main、col.sub、fg、bg 文本属性：cex、cex.axis、cex.lab、cex.main、cex.sub、font、font.axis、font.lab、font.main、font.sub 文本添加、坐标轴的自定义和图例 title()、main、sub、xlab、ylab、text() axis()、abline() legend() 多图绘制时候，可使用par()设置默认的图形参数 par(lwd=2, cex=1.5) 图形参数设置： par(optionname=value,…) par(pin=c(width,height)) 图形尺寸 par(mfrow=c(nr,nc)) 图形组合，一页多图 layout(mat) 图形组合，一页多图 par(mar=c(bottom,left,top,right)) 边界尺寸 par(fig=c(x1,x2,y1,y2),new=TURE) 多图叠加或排布成一幅图 R语言绘图颜色RColorBrewer包 三类调色板：sequential（渐变）/diverging（极端） /qualitative（分类变量） 参考学习博文链接： R语言入门]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MultiThread]]></title>
    <url>%2F2019%2F06%2F03%2FmultiThread%2F</url>
    <content type="text"><![CDATA[多线程 线程的状态：一个线程的生命周期： 多线程相关思维导图： Thread 方法：下表列出了Thread类的一些重要方法： 序号 方法描述 1 public void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 2 public void run() 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 public final void setName(String name) 改变线程名称，使之与参数 name 相同。 4 public final void setPriority(int priority) 更改线程的优先级。 5 public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。 6 public final void join(long millisec) 等待该线程终止的时间最长为 millis 毫秒。 7 public void interrupt() 中断线程。 8 public final boolean isAlive() 测试线程是否处于活动状态。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>multiThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F05%2F30%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC (Java DataBase Connection) 是通过JAVA访问数据库 一、MySQL基本 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 使用mysql-front管理数据库 mysql front下载地址 MySQL操作 1、创建与删除数据库 create/drop database dbName 2、创建表1234567CREATE TABLE hero ( id int(11) AUTO_INCREMENT, name varchar(30) , hp float , damage int(11) , PRIMARY KEY (id)) DEFAULT CHARSET=utf8; 3、插入数据insert into hero values (null, &#39;盖伦&#39;, 616, 100) 4、查询数据 查询所有数据 select * from hero 统计表中总共有多少数据 select count(*) from hero 分页查询 select * from hero limit 0,5 5、修改数据修改主键为1的数据 update hero set hp = 818 where id = 1 同理删除 delete hero set hp = 818 where id = 1 WHERE 子句类似于程序语言中的if条件，根据 MySQL 表中的字段值来读取指定的数据。 如果我们想再MySQL数据表中读取指定的数据，WHERE 子句是非常有用的。 使用主键来作为 WHERE 子句的条件查询是非常快速的。 如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。 二、JDBC1、导入mysql-jdbc的jar包（一般会放在新建的lib文件夹中） JDBC是一个规范，遵循JDBC接口规范，各个数据库厂家各自实现自己的驱动程序(Driver)，如下图所示: 2、初始化驱动12345678910 try &#123; //驱动类com.mysql.jdbc.Driver //就在 mysql-connector-java-5.0.8-bin.jar中 //如果忘记了第一个步骤的导包，就会抛出ClassNotFoundException Class.forName("com.mysql.jdbc.Driver");System.out.println("数据库驱动加载成功 ！"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 3、建立与数据库连接1Connection c = DriverManager.getConnection("jdbc:mysql://127.0.0.1（本机ip地址，数据库ip）:3306（mysql专用端口号）/数据库名?characterEncoding=UTF-8"（字符集）,"root"（账号名）, "admin"); 4、创建Satement/PreSatement Statement s = c.createStatement(); 引入包为java.sql.Satement PreSatement String sql = “insert into hero values(null,?,?,?)”; // 根据sql语句创建PreparedStatement PreparedStatement ps = c.prepareStatement(sql); // 设置参数 ​ ps.setString(1, “提莫”);​ ps.setFloat(2, 313.0f);​ ps.setInt(3, 50); // 执行 ps.execute(); excuteUpdate与excute区别不同1：execute可以执行查询语句然后通过getResultSet，把结果集取出来executeUpdate不能执行查询语句 不同2:execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等executeUpdate返回的是int，表示有多少条数据受到了影响 PreparedStatement优点 PreparedStatement有预编译机制，性能比Statement更快 防止SQL注入式入侵 e.g. select * from hero where name = ‘盖伦’ OR 1=1 因为有OR 1=1，这是恒成立的,就会把这个表里的数据全部查出来,响应变得极其缓慢 使用参数设置，可读性好，不易犯错 5、执行SQL语句CRUD是最常见的数据库操作，即增删改查C 增加(Create)R 读取查询(Retrieve)U 更新(Update)D 删除(Delete) 1)插入 String timo=”提莫” String sql =String.format( “insert into hero values(null,’%s’,313.0,50)”,timo); s.execute(sql); //执行sql语句 2）读取查询12345678ResultSet rs = s.executeQuery(sql);while (rs.next()) &#123; int id = rs.getInt("id");// 可以使用字段名 String name = rs.getString(2);// 也可以使用字段的顺序 float hp = rs.getFloat("hp"); int damage = rs.getInt(4); System.out.printf("%d\t%s\t%f\t%d%n", id, name, hp, damage); &#125; 3）更新 String sql = “update hero set name = ‘Tom’ where id =’2’ ‘’; 4)删除 String sql = “delete from hero where id = 5”; 6、关闭连接先关闭Satement，后关闭Connection 不过一般都是将其放在try（）中，因为它们都实现了AutoCloseable接口 DAODAO=DataAccess Object 数据访问对象，将数据库相关的操作都封装在类中 步骤1.DAO接口1234567891011121314151617181920package jdbc;import java.util.List;import charactor.Hero;public interface DAO&#123; //增加 public void add(Hero hero); //修改 public void update(Hero hero); //删除 public void delete(int id); //获取 public Hero get(int id); //查询 public List&lt;Hero&gt; list(); //分页查询 public List&lt;Hero&gt; list(int start, int count);&#125; 2.设计Hero类实现DAO接口将不同的操作都封装在不同的函数中 数据库连接池原理： 连接池在使用之前，就会创建好一定数量的连接。如果有线程需要连接，可以从连接池中借用，使用完毕后，线程就会把这个连接还给连接池。 倘若发生多线程并发情况，连接池里的连接被借用光了，那么其他线程就会临时等待，直到有连接被归还回来，再继续使用。整个过程，这些连接都不会被关闭，而是不断的被循环使用这样就节省了启动和关闭连接的时间。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket]]></title>
    <url>%2F2019%2F05%2F30%2FSocket%2F</url>
    <content type="text"><![CDATA[网络编程网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。 java.net包中提供了低层次的通信细节。 两种常用的网络协议： TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。 UDP：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。 Socket编程套接字（Socket）使用TCP提供了两台计算机之间的通信机制。 建立TCP连接的步骤： 服务器实例化一个ServerSocket对象，表示通过服务器上的端口通信 服务器调用ServerSocket类的accept()方法，该方法一直等待，直到客户端连接到服务器上给定的端口。 服务器在等待的时候，客户端实例化一个Socket对象，指定服务器名称和端口号来请求连接 Socket类的构造函数试图将客户端连接到指定服务器和端口号。如果通信被建立，则在客户端创建一个Socket对象能够与服务器端进行通信。 在服务器端，accept()方法返回服务器上一个新的Socket引用，给Socket连接到客户端的Socket。 Socket服务端实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package socket;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class Server extends Thread &#123;private ServerSocket serverSocket;//传入端口号 public Server(int port) throws IOException &#123; serverSocket = new ServerSocket(port); &#125; //重写run方法 public void run() &#123; while(true) &#123; System.out.println("等待远程连接，端口号为："+serverSocket.getLocalPort()+"......"); try &#123; //在指定端口号监听，看是否有连接请求过来 Socket server =serverSocket.accept(); System.out.println("远程主机地址：" + server.getRemoteSocketAddress()); //使用数据流对字节流进行封装 DataInputStream in = new DataInputStream(server.getInputStream()); System.out.println(in.readUTF()); //使用Scanner读取控制台的输入，并发送到服务端 DataOutputStream out = new DataOutputStream(server.getOutputStream()); Scanner sc = new Scanner(System.in); String str = sc.next(); out.writeUTF(str); //关闭 server.close(); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; &#125;public static void main(String[] args) &#123; // TODO 自动生成的方法存根 Thread t; try &#123; t = new Server(8000); t.run(); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125;&#125; Socket客户端实例12345678910111213141516171819202122232425262728293031323334353637package socket;import java.net.*;import java.util.Scanner;import java.io.*;public class Client &#123; public static void main(String[] args) &#123; String ServerName; int port; Scanner sc=new Scanner(System.in); System.out.println("请输入你要连接的服务端IP："); ServerName=sc.next(); System.out.println("请输入你要连接的端口号："); port=sc.nextInt(); try &#123; Socket client=new Socket(ServerName,port); OutputStream outToServer = client.getOutputStream(); DataOutputStream out = new DataOutputStream(outToServer); String str; str=sc.next(); out.writeUTF(str); InputStream inFromServer = client.getInputStream(); DataInputStream in = new DataInputStream(inFromServer); System.out.println("服务器响应： " + in.readUTF()); client.close(); &#125; catch (UnknownHostException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125;&#125;&#125; InetAddress 类的方法这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法： 序号 方法描述 1 static InetAddress getByAddress(byte[] addr) 在给定原始 IP 地址的情况下，返回 InetAddress 对象。 2 static InetAddress getByAddress(String host, byte[] addr) 根据提供的主机名和 IP 地址创建 InetAddress。 3 static InetAddress getByName(String host) 在给定主机名的情况下确定主机的 IP 地址。 4 String getHostAddress() 返回 IP 地址字符串（以文本表现形式）。 5 String getHostName() 获取此 IP 地址的主机名。 6 static InetAddress getLocalHost() 返回本地主机。 7 String toString() 将此 IP 地址转换为 String。 Socket类的方法Socket 类有五个构造方法. 序号 方法描述 1 public Socket(String host, int port) throws UnknownHostException, IOException. 创建一个流套接字并将其连接到指定主机上的指定端口号。 2 public Socket(InetAddress host, int port) throws IOException 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 3 public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException. 创建一个套接字并将其连接到指定远程主机上的指定远程端口。 4 public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException. 创建一个套接字并将其连接到指定远程地址上的指定远程端口。 5 public Socket() 通过系统默认类型的 SocketImpl 创建未连接套接字 Socket类其他常用方法： 序号 方法描述 1 public void connect(SocketAddress host, int timeout) throws IOException 将此套接字连接到服务器，并指定一个超时值。 2 public InetAddress getInetAddress() 返回套接字连接的地址。 3 public int getPort() 返回此套接字连接到的远程端口。 4 public int getLocalPort() 返回此套接字绑定到的本地端口。 5 public SocketAddress getRemoteSocketAddress() 返回此套接字连接的端点的地址，如果未连接则返回 null。 6 public InputStream getInputStream() throws IOException 返回此套接字的输入流。 7 public OutputStream getOutputStream() throws IOException 返回此套接字的输出流。 8 public void close() throws IOException 关闭此套接字。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO]]></title>
    <url>%2F2019%2F05%2F26%2FIO%2F</url>
    <content type="text"><![CDATA[I/O]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections]]></title>
    <url>%2F2019%2F05%2F26%2Fcollections%2F</url>
    <content type="text"><![CDATA[集合框架思维导图 Java集合框架概览 三种基本集合框架：1、List（有序、可重复）List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 2、Set（无序、不能重复）Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 3、Map（键值对、键唯一、值不唯一）Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 区别：Vector和ArrayList1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。 arraylist和linkedlist1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 HashMap与TreeMap1、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。2、在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。两个map中的元素一样，但顺序不一样，导致hashCode()不一样。同样做测试：在HashMap中，同样的值的map,顺序不同，equals时，false;而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。 HashTable与HashMap1、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。2、HashMap允许存在一个为null的key，多个为null的value 。3、hashtable的key和value都不允许为null。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>collections</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2019%2F05%2F22%2FMarkDown%2F</url>
    <content type="text"><![CDATA[Markdown使用​使用工具为Typora(其实MP2和sublime3也可以，但没快捷键操作)#### （1）标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 （2）粗体、斜体、删除线和下划线Markdown 语法： 1234*斜体***粗体*****加粗斜体***~~删除线~~ Typora 快捷键： Ctrl+I：斜体 Ctrl+B：粗体 Ctrl+U：下划线 Alt+Shift+5：删除线 （3）引用块Markdown 语法：&gt; 文字引用 Typora 快捷键： Ctrl+Shift+Q （4）代码块Markdown 语法： 行内代码 12多行代码多行代码 Typora 快捷键： 行内代码：Ctrl+Shift+` 多行代码：Ctrl+Shift+K （5）公式块Markdown 语法： 123$$数学公式$$ Typora 快捷键： Ctrl+Shift+M （6）分割线Markdown 语法： 12345方法一：---方法二：+++方法三：*** （7）列表Markdown 语法： 12345671.有序列表项* 无序列表项+ 无序列表项- 无序列表项 Typora 快捷键： 有序列表项：Ctrl+Shift+[ 无序列表项：Ctrl+Shift+] （8）表格Markdown 语法： 1234表头1|表头2-|-|-内容11|内容12内容21|内容22 e.g ID name 01 Tom 02 Jack Typora 快捷键： Ctrl+T （9）超链接Markdown语法： 12345678方法一：[链接文字](链接地址 &quot;链接描述&quot;)例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)方法二：&lt;链接地址&gt;例如：&lt;https://www.example.com/&gt;方法三：[链接文字]（标记） 标记=url Typora快捷键： Ctrl+K （10）图片Markdown语法： 12![图片文字](图片地址 &quot;图片描述&quot;)例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;) Typora快捷键： Ctrl+Shift+I e.g: 说明：在 Hexo中 插入图片时，请按照以下的步骤进行设置 将 站点配置文件 中的 post_asset_folde 选项的值设置为 true 在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件 这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 ![示例图片](title/example.PNG &quot;示例图片&quot;) 添加图片 （11）表情符号 :表情单词: e.g: :call_me_hand: :happy: 发布博客在站点文件夹中打开 git bash，输入如下命令创建文章，其中 title 为文章的标题 1$ hexo new &quot;title&quot; 当输入命令后，就会在 source/_post 文件夹下创建一个文件，命名为：title.md 在站点文件夹中打开 git bash，输入如下命令部署和发布文章 1$ hexo g -d 1建议：在使用 hexo g 部署之后，可以先使用 hexo s 运行本地站点，然后在浏览器输入地址 http://lacolhost:4000/ 查看运行结果，检查无误后再使用 hexo d 发布 Latex公式学习：$$\begin{matrix} 1 &amp; x &amp; x^2\ 1 &amp; y &amp; y^2\ 1 &amp; z &amp; z^2\ \end{matrix} X=\left| \begin{matrix} x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\ x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d}\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\ \end{matrix}\right|$$ Typora使用Latex代码插入公式 $$x^2 \ x_i \\alpha \ \beta \pi \phi \sqrt5 \cdots$$ $$\int_1^n \dots lim_{x\to \infty} \frac{8}{4}$$ $$ $$ 此文参考：Hexo系列（五）撰写文章 最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 这个只是用来对于写$x^2$博客的一个备忘]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment &lt;https://hexo.io/zh-cn/docs/commands.html &gt;]]></content>
  </entry>
</search>
