<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构复习（二）]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-1%2F</url>
    <content type="text"><![CDATA[栈和队列 第三章 栈和队列一、栈栈（stack）是限定仅在队尾进行插入或删除操作的线性表。 线性表的尾端为栈顶，表头为栈底。 特点：栈是LIFO（Last In First Out），先存进去的数据只能最后被取出来，进出顺序逆序，即先进后出，后进先出。 栈的表示和实现（top、base、为空或满的判断条件、元素个数） 顺序栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 //-------栈的顺序存储表示---------#define STACK_INIT_SIZE 100#define STACKINCREMENT 10typedef int SElemType;typedef struct &#123; SElemType *base; //在栈构造之前和销毁之后，base的值为NULL SElemType *top; //栈顶指针 int stackSize; //当前分配的存储空间&#125;SqStack;//构造一个空栈Status InitStack(SqStack &amp;S)&#123; S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType)); if (!S.base) exit(OVERFLOW); S.top = S.base; S.stackSize = STACK_INIT_SIZE; return OK;&#125;///销毁栈S，S不再存在Status DestroyStack(SqStack &amp;S)&#123; S.stackSize = 0; free(S.base); S.base = S.top = NULL; return OK;&#125;////把S置为空栈Status ClearStack(SqStack &amp;S)&#123; S.top = S.base; return OK;&#125;//判断栈是否为空Status StackEmpty(SqStack &amp;S)&#123; if (S.base == S.top) return TRUE; else return FALSE;&#125;//返回S的元素个数，即栈的长度int StackLength(SqStack S) &#123; return (S.top - S.base);&#125;//获取栈顶元素Status GetTop(SqStack S, SElemType &amp;e)&#123; if (StackEmpty(S))return ERROR; e= *(S.top - 1); return OK;&#125;//压栈Status Push(SqStack &amp;S, SElemType e)&#123; if (S.top - S.base &gt;= S.stackSize)//栈满，追加存储空间 &#123; S.base = (SElemType *)realloc(S.base, (S.stackSize + STACKINCREMENT) * sizeof(SElemType)); if (!S.base) exit(OVERFLOW); S.top = S.base + S.stackSize; //将top指针指向要添加的位置去 S.stackSize += STACKINCREMENT; &#125; *(S.top++) = e; return OK;&#125;//弹栈Status Pop(SqStack &amp;S, SElemType &amp;e)&#123; if (S.base == S.top) return ERROR; e = *(--S.top); return OK;&#125;//遍历栈void visit(SElemType a) &#123; printf("%d\n", a);&#125;Status StackTraverse(SqStack S, void(*visit)(SElemType))&#123; printf("Stack Traverse: \n"); SElemType *p = S.base; while (p != S.top) &#123; visit(*p++); &#125; return OK;&#125; 链式栈 1234567891011//------------链式栈的存储结构----------teypedef struct StackNode&#123;ElemType data; // 存放栈的数据StackNode *next;&#125; StackNode, *LinkStackPtr;teypedef struct LinkStack&#123;LinkStackPrt top; // top指针int count; // 栈元素计数器&#125; 栈的相关应用 3.1 数制转换 123456789101112131415161718//对于输入任意的一个非负十进制整数，打印输出与其等值的八进制数void Conversion()&#123; SqStack S; InitStack(S); int e, Num; scanf_s("%d", &amp;Num); while (Num) &#123; Push(S, Num % 8); Num /= 8; &#125; while (!StackEmpty(S)) &#123; Pop(S, e); printf("%d ", e); &#125; printf("\n");&#125; 3.2 括号匹配的检验 12345678910111213141516171819202122232425262728293031323334353637383940414243int Match(char ch, char str) &#123;//检查是否匹配 if (ch == '('&amp;&amp;str == ')') return TRUE; if (ch == '['&amp;&amp;str == ']') return TRUE; if (ch == '&#123;'&amp;&amp;str == '&#125;') return TRUE; return FALSE;&#125;void BracketMatch(char *str) &#123;//str为输入的字符串 char ch; int i = 0; SqStack S; InitStack(S); while (str[i] != '\0') &#123; switch(str[i]) &#123; case '(': case'[': case'&#123;': Push(S, str[i]); break; case')': case']': case'&#125;': if (StackEmpty(S)) &#123; printf("括号不匹配！\n"); return; &#125;else &#123; GetTop(S, ch); if (Match(ch, str[i])) Pop(S, ch); else &#123; printf("括号不匹配！\n"); return; &#125; &#125; &#125; i++; &#125; if (StackEmpty(S)) printf("括号匹配\n"); else printf("括号不匹配！\n");&#125; 3.3 行编辑程序算法实现（部分） 12345678910111213141516171819202122232425//在终端窗口有一新行，没有输入内容，输入Ctrl+D表示EOF//在终端窗口有一新行，有输入内容，按两次Ctrl+D表示EOFvoid LineEdit()// 利用字符栈，从终端接收一行并传送至调用过程的数据区&#123; SqStack S; InitStack(S); char c, ch = getchar(); while (ch != EOF) &#123; while (ch != EOF &amp;&amp; ch != '\n') &#123; switch (ch) &#123; case'#':Pop(S, c); break; //前一个元素输入错误，想要删除 case'@':ClearStack(S); break; //当前错误过多，删除整行 default:Push(S, ch); break; //存入栈 &#125; ch = getchar(); &#125; StackTraverse(S, visit); ClearStack(S); if (ch != EOF) ch = getchar();//如果行没结尾，则直到读到结尾 &#125; DestroyStack(S);&#125; 二、队列队列（queue）是限定仅在表头进行删除，表尾删除操作的线性表。 特点：先进先出（FIFO） 循环队列（front、rear、为空或满的判断条件、元素个数） 与顺序栈类似，在队列的顺序结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个指针front和rear分别指示队列头元素及队列尾元素的位置。 用此方法表示循环队列，就无法用Q.front=Q.rear来判断队列空间是空还是满。可有两种处理方法：其一是另设一个标志位以区别队列是空还是满；其二是少用一个元素空间，约定以“队列头指针在队列尾指针的下一位置上”作为队列呈满状态的标志。 从上述分析可见，C语言中不能用动态分配的一维数组来实现循环队列。如果要用，就必须为它设定一个最大队列长度；若无法预估所用队列的最大长度，建议使用链队列。 描述： 1234初始化建空队列时，令front=rear=0每当插入新的队尾元素时，“尾指针+1；每当删除队列头元素时，“头指针-1”；因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940#define MAXSIZE 100 //最大队列长度typedef struct &#123; int *base;//初始化的动态分配储存空间，int可以换成元素的类型 int front; int rear; //队尾 //非链式，应该是顺序存储&#125;SqQueue;//---------------------循环队列的基本操作的算法描述bool InitQueue(SqQueue &amp;Q) &#123; //构造一个空队列Q Q.base = (int *)malloc(MAXSIZE * sizeof(int)); if (!Q.base)exit(OVERFLOW); Q.front = Q.rear=0; return 1;&#125;int QueueLength(SqQueue &amp;Q)&#123; //返回Q的元素个数，即队列长度 return((Q.rear - Q.front + MAXSIZE) % MAXSIZE);&#125;bool EnQueue(SqQueue &amp;Q, int e)&#123; //判断条件 if ((Q.rear + 1) % MAXSIZE == Q.front)return 0; Q.base[Q.rear] = e; Q.rear = (Q.rear + 1) % MAXSIZE; return 1;&#125;bool DeQueue(SqQueue &amp;Q,int &amp;e)&#123; //若队列不空，则删除Q的队头元素，用e返回其值 if (Q.front == Q.rear)return 0; e = Q.base[Q.front]; Q.front = (Q.front + 1) % MAXSIZE;//由于下标是动态的，可能对应+1就到了开头的情况 return 1;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习（三）]]></title>
    <url>%2F2019%2F06%2F25%2F%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[串和数组 第四章 串一、串的概念与存储结构串（字符串）：是零个或多个字符 组成的有限序列。 串值：双引号括起来的字符序列是串值。 串长：串中所包含的字符个数称为该串的长度。 空串（空的字符串）：长度为0的串称为空串，不包含任何字符。 空格串（空白串）：构成串的所有字符都是空格的串称为空白串。空串和空白串不同。如“ ”和“”分别表示长度为1 的空白串和长度为0 的空串。 子串：串中任意个连续字符组成的子串称为该串的子串，包含子串的串相应地称为主串。 子串的序号：将子串在主串中首次出现时的该子串的首字符对应主串中的序号，称为子串在主串中的序号(或位置)。 注意：空串是任意串的子串，任意串是其自身的子串。 串相等：如果两个串的串值相同，称为串相等。即串的长度相等，且各个对应位置的字符都相同时才相等。 通常在程序中使用的串可分为两种：串变量和串常量： 二、串的存储表示和实现————两种存储结构：顺序和链式。串的逻辑结构和线性表极为相似，区别仅在与串的数据对象约束为字符集。 在串的基本操作中基本以“串的整体”作为操作对象。 串的链式存储结构和线性表的串的链式存储结构类似，采用单链表来存储串，结点的构成是： data域：存放字符，data域可存放的字符个数称为结点的大小。 next域：存放指向下一个结点的指针。 定长顺序存储表示：用一组地址连续的存储单元来依次存储串中的字符序列。将串定义为字符数组，利用串名可以直接访问串值。此方式，串的存储空间在编译时确定，其大小不能改变。 堆分配存储方式：仍然用一组地址连续的存储单元来依次存储串中的字符序列，但串的存储空间是在程序运行时根据串的实际长度动态分配的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 100//串的顺序存储 typedef struct st&#123; char *ch; //串存放的起始地址，串中第i个字符存储在ch[i-1]中 int length; //串的长度 int strsize; //分配的存储空间的大小，如果不足，在通过realloc()分配增加空间&#125;string; //串的初始化操作string CreateNullString()&#123; string s; s.length = 0; s.ch = (char*)malloc(MAXSIZE *sizeof(char)); s.strsize = MAXSIZE; return s;&#125; //判断空串int isEmpty(string s)&#123; if (s.length == 0) return 1; else return 0;&#125; //赋值操作void StringAssign(string *s1, char s2[])&#123; int i = 0; while (s2[i] != '\0') // '\0' 是字符串的结束符，任何字符串之后都会自动加上'\0' i++; //计算s2的长度 if (i&gt;s1-&gt;strsize)&#123; //所赋值的字符数组超过字符串的默认容量，则增加存储空间 s1-&gt;ch = (char*)malloc(i*sizeof(char)); s1-&gt;strsize = i; &#125; s1-&gt;length = i; for (i = 0; i&lt;s1-&gt;length; i++) s1-&gt;ch[i] = s2[i]; //从第一个字符开始逐个字符赋值&#125; //串拷贝操作void StringCopy(string *s1, string s2)&#123; if (s1-&gt;strsize&lt;s2.length)&#123; //realloc则对malloc申请的内存进行大小的调整. s1-&gt;ch = (char*)realloc(s1-&gt;ch, s2.length*sizeof(char)); s1-&gt;strsize = s2.length; &#125; s1-&gt;length = s2.length; int i; for (i = 0; i&lt;s1-&gt;length; i++) s1-&gt;ch[i] = s2.ch[i];&#125; //求串的长度int StringLength(string s)&#123; return s.length;&#125; //串的连接操作void concat(string *s, string s1, string s2)&#123; if (s-&gt;strsize&lt;s1.length + s2.length)&#123; s-&gt;ch = (char*)realloc(s-&gt;ch, (s1.length + s2.length)*sizeof(char)); s-&gt;strsize = s1.length + s2.length; &#125; s-&gt;length = s1.length + s2.length; //两串连接 int i; for (i = 0; i&lt;s1.length; i++) //将s1复制到s中 s-&gt;ch[i] = s1.ch[i]; for (; i&lt;s-&gt;length; i++) s-&gt;ch[i] = s2.ch[i - s1.length]; //将s2复制到s中去&#125; //取子串操作int substr(string s, int i, int len, string *t)&#123; /* i表示从字符串s的第i个位置开始截取（索引从1开始） len表示截取字符串的长度 */ if (i &lt;= 0 || i&gt;s.length || len&lt;0 || len&gt;s.length - i + 1) //参数不合法 return 0; if (t-&gt;length&lt;len)&#123; //存储空间不够，继续分配存储空间 t-&gt;ch = (char*)realloc(t-&gt;ch, len*sizeof(char)); t-&gt;strsize = len; &#125; t-&gt;length = len; int k; for (k = 0; k&lt;t-&gt;length; k++) t-&gt;ch[k] = s.ch[i - 1 + k]; return 1;&#125; //插入操作int insertString(string *s, int i, string t)&#123; //在字符串s的第i个位置插入字符串t if (i &lt;= 0 || i&gt;s-&gt;length + 1) return 0; if (s-&gt;strsize&lt;s-&gt;length + t.length)&#123; //空间不足 s-&gt;ch = (char*)realloc(s-&gt;ch, (s-&gt;length + t.length)*sizeof(char)); s-&gt;strsize = s-&gt;length + t.length; &#125; int k; for (k = s-&gt;length - 1; k &gt;= i - 1; k--) //将s中的后i个字符后移到后面 s-&gt;ch[k + t.length] = s-&gt;ch[k];//end[][][] ==&gt; e[][][]nd s-&gt;length = s-&gt;length + t.length;//s-&gt;length=3+3 for (k = 0; k&lt;t.length; k++) //将t的值赋值给s s-&gt;ch[k + i - 1] = t.ch[k];//e[][][]nd==&gt;eaaand return 1;&#125; //删除操作int deleteString(string *s, int i, int len)&#123; //从s的第i个字符开始删除len个字符 if (i &lt;= 0 || i&gt;s-&gt;length || len&lt;0 || len&gt;s-&gt;length - i + 1) //参数不合法 return 0; int k; for (k = i + len - 1; k&lt;s-&gt;length; k++) //从s的i+len-1个位置开始将其后的所有字符前移 s-&gt;ch[k - len] = s-&gt;ch[k]; s-&gt;length -= len; return 1;&#125; //输出操作void print(string s)&#123; int i; for (i = 0; i&lt;s.length; i++) printf("%c", s.ch[i]); printf("\n");&#125; int main()&#123; string s1 = CreateNullString(); string s2 = CreateNullString(); string s3 = CreateNullString(); char ch[MAXSIZE]; printf("请输入主串：\n"); //输入friend gets_s(ch); //赋值操作 StringAssign(&amp;s1, ch); printf("主串 s1 为："); print(s1); //将字符s1拷贝到s2 StringCopy(&amp;s2, s1); printf("拷贝串操作结果如下，结果如下 s2 ："); print(s2); printf("删除操作（1——s1.length-3 全删）："); //删除操作 deleteString(&amp;s2, 1, s1.length - 3); print(s2); printf("插入操作,插入到s2的第2个位置上，请输入插入的字符串："); gets_s(ch); //赋值操作 把输入的字符放到s3中 StringAssign(&amp;s3, ch); //进行插入操作,将s3插入到s2的第二个位置上 insertString(&amp;s2, 2, s3); print(s2); printf("取子串操作（取s1的子串【2-4】)："); //提取friend 中[2-4]位置元素-rie substr(s1, 2, 3, &amp;s3); print(s3); //s1==&gt;friend s3==&gt;rie printf("串连接操作【将s1与s3合并】："); concat(&amp;s1, s1, s2); print(s1);&#125; 块链存储方式：是一种链式存储结构表示。 若每个结点仅存放一个字符，则结点的指针域就非常多，造成系统空间的浪费，为节省存储空间，考虑串结构的特殊性，使每个结点存放若干个字符，这种结构称为块链结构。 串模式匹配（Next[j]值求解） KMP模式匹配： 123456789101112int Index_KMP(SString S,SString T,int pos)&#123;//利用模式串T的next函数求T在主串S中第pos个字符位置之后的元素int i =pos,j=1;while(i&lt;S[0]&amp;&amp;j&lt;T[0])&#123; if(j==0||S[i]==T[j])&#123; ++i;++j; //继续比较后继元素 &#125; else j=next[j]; &#125; if(j&gt;T[0])return i-T[0]; else return 0;&#125; 得到next[i]方法： 123456789101112void get_next(SString T, int next[])&#123; int i=1,j=0; next[1]=0; while(i&lt;T[0])&#123; if(j==0||T[i]==T[j])&#123; i++;j++; if(T[i]!=T[j]) next[i]=j; else next[i]=next[j]; &#125; &#125;&#125; 第五章 数组和广义表 1.数组的概念 数组是由n（n&gt;1）个具有相同数据类型的数据元素a1,a2,…,an组成的有序序列，且该序列必须存储在一块地址连续的存储单元中。 数组中的数据元素具有相同数据类型； 数组是随机存取结构，给定一组下标，就可以访问与其对应的数据元素； 数组中的数据元素个数是固定的。 2.数组元素地址的计算 二维数组 a[m][n] 行优先顺序存储：LOC[a~ij~]=LOC[a~00~]+(i*m+j)*sizeof(ElemType) 3.稀疏矩阵的压缩存储（三元组表示法） 对于稀疏矩阵，采用压缩存储方法时，只存储非0元素。必须存储非0元素的行下标值，列下标值、元素值。 一个三元组（i,j,aij）唯一确定稀疏矩阵的一个非零元素。 4.广义表（长度、深度、求表头Head、求表尾Tail操作） 广义表又称列表，是由n个元素组成的有穷序列：LS=(a1,a2,….,an)。其中ai或是原子项，或是一个广义表。LS是广义表的名字，n为长度。若ai是广义表，则称为LS的子表。 习惯上原子用小写字母，子表用大写字母。若广义表LS非空时： a1（表中的第一个元素）称为表头； 其余元素组成的子表称为表尾； 广义表中所包含的元素(包括原子和子表)的个数称为表的长度。 广义表中括号的最大层数称为表深(度)。 广义表本身是一个递归表。即列表本身也可以是自己的一个子表。 根据对表头、表尾的定义，任何一个非空广义表的表头可以是原子，也可以是子表，而表尾必定是广义表。 e.g. A=()——A是空表，长度为0 B=((),(e),(a,b,c))——B长度为3，深度为3 GetHead(B)=() GetTail(B)=((e),(a,b,c)) 注意()和(())不同，前者为空表，长度为0，后者长度为1，表头和表尾均为()]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习（一）]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[线性表 第一章 绪论数据结构是相互之间存在一种或多种特定特定关系的数据元素的集合。 重要术语： 1、数据：对客观事物的符号表示，指所有能输入到计算机中并被计算机程序处理的符号的总称。 2、数据项：数据项是数据的不可分割的最小单位。 3、数据元素：数据的基本单位，在计算机中作为一个整体进行考虑和处理，一个数据元素由多个数据项组成。 4、数据对象：性质相同的数据元素的集合，是数据的一个子集。 数据结构的四种结构： 算法效率度量： 事后统计的方法：对运行结果进行统计分析，得出执行效率。 事前分析估算：估算算法的时间复杂度——算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。 时间复杂度常用大O符号表述，如O(1),O(n),O(n)等，不包括这个函数的低阶项和首项系数。 一般我们最常用的办法是讨论算法在最坏情况下的时间复杂度。 常见的 O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2) 对数据进行操作：初始化、判断是否是空、存取、统计个数、遍历、插入、删除、查找、排序 ————用算法进行描述。 第二章 线性表一、线性表的定义及特性 定义：线性表是具有相同类型的 n（≥0）个数据元素的有限序列 线性表的顺序存储（顺序表）和链式存储（链表） 1.顺序表（SeqList)使用一维数组一次存放书元素。 123456789101112/-------------线性表的动态分配顺序存储结构---------#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量#define LISTINCREMENT 10 //线性表的存储空间的分配增量typedef int ElemType;//额外添加类型名定义// 采用动态分配的顺序存储结构typedef struct &#123; ElemType *elem; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量&#125;SqList; 一维数组占用一块内存空间，每个存储单元的地址是连续的，通过下标识别元素，它的下标就代表了他的存储单元序号，也就表示了它的位置。 查找顺序表中的元素是方便的，根据下标就可以取出要取的元素。 当顺序表的容量不够时，顺序表不能就地扩容，要申请另一个更大容量的数组进行数组元素复制。Java源代码中的ArrayList类扩容实现过程是：先申请增加的容量是原本容量的二分之一，生成一个原本容量的二分之三的内存地址，再将所有元素进行复制过去。 2.线性表的链式存储结构(链表LinkedList)是用若干地址分散的存储单元存储数据元素，逻辑上相邻的数据元素在物理位置上不一定相邻。 存储一个数据元素的存储单元成为结点Node，单链表的表示方式：结点（数据域，地址域）。 12345678//链式存储结构typedef struct Node&#123; int data; struct Node* next;&#125;Node;typedef struct Node* PNode; 二、线性表顺序讯相互及基本操作（插入、删除） 对于插入、删除元素：先根据下标找到相应位置，若插入元素，将新插入插入位置后，将被加入位置的旧元素及之后的元素向后移动，移动次序是由后向前。若删除元素，将要删除的元素删除，其后的元素向前移动。插入和删除的操作时间主要用于移动元素。 123456789101112131415161718192021222324252627282930313233343536373839404142/插入操作,插入一个元素到线性表的第i个位置//1.判断线性表是否已满//2.判断i的位置是否合理//3.从最后一个元素到当前元素后移//4.当前元素插入Status InsertList_Sq(SqList &amp;L, int i, ElemType e)&#123; if (i&lt;1 || i&gt;L.length + 1)return ERROR; ElemType *newBase; if (L.length &gt;= L.listsize) &#123; newBase = (ElemType *)realloc(L.elem, (L.listsize + LISTINCREMENT) * sizeof(ElemType)); if (!newBase)exit(OVERFLOW); L.elem = newBase; L.listsize += LISTINCREMENT;&#125;//前一部分的作用是怕预先分配的内存不够用或者输入值异常所做的处理ElemType* q = &amp;(L.elem[i - 1]);//先将要插入部分之后的元素后移一位for (ElemType *p = &amp;(L.elem[L.length - 1]); p &gt;= q; p--) *(p + 1) = *p; //插入e，并表长加1*q = e;++L.length;return OK;&#125;Status DeleteList_Sq(SqList &amp;L, int i, ElemType &amp;e)&#123; if (i&lt;1 || i&gt;L.length)return ERROR; ElemType* q = &amp;(L.elem[i - 1]); e = *q; for (ElemType *p = &amp;(L.elem[L.length - 1]); p &gt;= q; p--) *(p - 1) = *p; L.length--;return OK;&#125; 三、单链表的操作（插入、删除、查找、归并等） 对于单链表的操作：遍历操作是从第0个结点开始，沿着结点的Next链，依次访问单链表中的每个结点，并且每个节点只访问一次。插入（删除）操作：根据要插入（删除）的结点数，从第0个结点遍历找到要插入（删除）的位置，将要插入的数据元素插入（将要删除的元素删除），改变原来结点间的链接关系，不用移动数据元素。而操作所花的时间都在查找上面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162//初始化链表bool InitList(PNode* pHead)&#123; *pHead = (PNode)malloc(sizeof(Node)); if (!(*pHead))//分配空间失败 &#123; return false; &#125;(*pHead)-&gt;next = NULL;return true;&#125;//创建链表，从头插入void CreateListHead(PNode pHead)&#123; PNode p = pHead; int num, data; printf("清输入要创建的节点个数\n"); scanf_s("%d", &amp;num); for (int i = 0; i &lt; num; i++) &#123; //先新造一个节点 scanf_s("%d", &amp;data); PNode q = (PNode)malloc(sizeof(Node)); (*q).data = data; //将新节点放在头结点后 q-&gt;next = p-&gt;next; p-&gt;next = q; &#125;&#125;//创建链表，从尾插入void CreateListTail(PNode pHead)&#123; PNode p = pHead; int num, data; printf("清输入要创建的节点个数\n"); scanf_s("%d", &amp;num); for (int i = 0; i &lt; num; i++) &#123; scanf_s("%d", &amp;data); PNode q = (PNode)malloc(sizeof(Node)); (*q).data = data; p-&gt;next = q; p = q; &#125; (*p).next = NULL;&#125;//第i个位置插入一个链表节点bool ListInsert(PNode pHead, int i, int val)&#123; int j = 0; PNode p = pHead; PNode q = (PNode)malloc(sizeof(Node)); while (p &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; j++; &#125; if (!p || j &gt; i - 1) &#123; return false; &#125; (*q).data = val; q-&gt;next = p-&gt;next; p-&gt;next = q; return true;&#125;//删除第i个位置的节点bool ListDelete(PNode pHead, int i, int* val)&#123; int j = 0; PNode p = pHead; while (p-&gt;next &amp;&amp; j &lt; i - 1)//注意while(p-&gt;pNext!=NULL&amp;&amp;i&lt;pos-1)与while(p!=NULL&amp;&amp;i&lt;pos-1)的差别，比如链表长度为6，当数大于等于8时有区别 &#123; p = p-&gt;next; j++; &#125;if (!p-&gt;next || j &gt; i - 1)&#123; return false;&#125;PNode q = p-&gt;next;*val = q-&gt;data;p-&gt;next = q-&gt;next;free(q);return true;&#125;//查找算法//类型一：获取链表第i个元素的值bool ListGetElement(PNode pHead, int i, int&amp; val)//val存储返回值&#123; int j = 0; PNode p = pHead; while (p-&gt;next &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; j++; &#125; if (!p-&gt;next || j &gt; i - 1) &#123; return false; &#125; val = p-&gt;next-&gt;data; return true;&#125;//类型二：获取链表元素值val的位置/* 初始条件：顺序线性表L已存在 *//* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 *//* 若这样的数据元素不存在，则返回值为0 */int ListLocateElement(PNode pHead, int val)&#123; PNode p = pHead-&gt;next; int i = 0; while (p) &#123; i++; if (p-&gt;data == val) return i; p = p-&gt;next; &#125; return 0;&#125;//归并void MergeList_L(pNode &amp;La,pNode &amp;Lb,pNode &amp;Lc)&#123; //已知单链线性表La和Lb的元素也按值非递减排列 //归并La和Lb得到新的单链表Lc,Lc的元素也按非递减排列 pNode pa=La-&gt;next; pNode pb=Lb-&gt;next; Lc=La; pNode pc=Lc; while(pa&amp;&amp;pb)&#123; if(pa-&gt;data&lt;=pb-&gt;data)&#123; pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; &#125; else&#123; pc-&gt;next=pb; pc=pb; pb=pb-&gt;next; &#125; &#125; //插入剩余片段,如果pa尾结点不为空，因为之前的循环结束条件是pa和pb中有一个为空，即一个表归并完 (pc-&gt;next=pa)!= NULL ? pa : pb; free(Lb);&#125; 四、双向链表单链表结点中只有一个指向其后继的指针，这使得单链表只能从头到尾依次顺序的向后遍历，若要访问某个结点的前驱，只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)；为克服以上缺点，引入双链表，一个结点含有两个指针，分别指向其前驱结点和后继结点。 1234567891011//------线性表的双向链表存储结构----------typedef struct DuLNode&#123;ElemType data;struct DuLNode *prior; //前驱指针struct DuLNode *next; //后继指针&#125;DuLNode,*DuLinkList; 和单向链表相比有以下优势： 插入删除不需要移动元素外，可以原地插入删除 可以双向遍历 初始化+尾插法图示： 1//head始终指向头结点，p指向尾节点，方便后续算法使用 删除单个图示：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R]]></title>
    <url>%2F2019%2F06%2F04%2FR%2F</url>
    <content type="text"><![CDATA[R语言 一、R的数据结构1、对象和属性赋值：&lt;- 查看数值类型class(x) 属性(attribute) 名称(name) 维度(dimensions: matrix, array) 类型(class) 长度(length) 向量(vector) 只能包含同一类型的对象 创建对象 vector(“type”,length= ) c() x &lt;- 1:4 强制类型转换 as.logical()/as.numeric()/as.character() 矩阵(matrix) 向量+维度属性(整数向量：nrow，ncol) 创建矩阵 matrix(): 先列后行 vector()+dim() 按行/列拼接矩阵 rbind()/cbind() 查看向量属性 attributes() 列表(list) 可以包含不同类型的对象 创建列表 list() 123456# list l &lt;- list("a",2,10L,3+4i,TRUE) l2&lt;-list(a=1,b=2,c=3) l3&lt;- list(c(1,2,3),c(4,5,6,7)) x &lt;- matrix(1:6,nrow = 2,ncol=3) dimnames(x)&lt;-list(c("a","b"),c("e","f","g")) 因子(factor) 分类数据/有序 vs. 无序 整数向量+标签(label)(优于整数向量) Male/Female vs. 1/2 创建因子 factor() 整体查看因子 table() 去除因子属性 unclass() 缺失值(missing value) NA/NaN: NaN属于NA，NA不属于NaN NA有类型属性：integer NA，character NA等。而NaN只有integer 查看元素是否为缺失值 is.na()/is.nan() 数据框(data frame) 存储表格数据 视为各元素长度相同的列表 每个元素代表一列数据 每个元素的长度代表行数 元素的类型可以不同 创建数据框 1df &lt;- data.frame(id=c(1,2),name=c("a","b"),gender=c(TRUE,FALSE)) 日期和时间 日期：Date 当前时间：date()/Sys.Date() weekdays()/months()/quarters() 季度 设置时间 x &lt;- as.Date(“2019-01-01”) 时间：POSIXct/POSIXlt 距离1970-01-01的秒数/Sys.time() POSIXct:整数，常用于存入数据框 POSIXlt:列表，还包含星期、年、月、日等信息 获取某个数组里面的内容用$ 二、构建子集原始数据 -&gt; 预处理后的数据 基本方法 []:提供一个或多个类型相同的元素 元素下标从1开始 枚举输出x[1:4] 逻辑判断x[x5] 按元素名字提取a[“name”] [[]]:从列表或数据框中提取元素 $:按名字从列表或数据框中提取元素 矩阵的子集 以向量形式1行2列的元素 x[1,2] 输出一整行 x[1, ] 输出x(2,3)和x(2,1) x[2,c(1,3)] 以矩阵形式返回 x[1,2,drop=”FALSE”] 数据框的子集 which(x$v1&gt;2)返回满足条件的数值 构建子集 subset(dateType,条件) 列表的子集 x[1]/x[“id”] 列表的元素 x[[1]]/x[[“id”]]/x$id 列表的内容 嵌套列表 x[[1][2]]/x[c(1,2)] 不完全匹配 x[[“a”,exact=FALSE]]/x$a 处理缺省值 返回x,y对应位置是否有缺省值，有返回FALSE complete.cases(x,y) 向量化操作 12345678910111213x &lt;- 1:5y &lt;- 6:10#每个向量对应位置的值做运算x+yx*yx1&lt;-matrix(1:4,nrow=2,ncol=2)y1&lt;-matrix(rep(2,4),nrow = 2,ncol = 2)x1+y1x1/y1x1 %*% y1 三、重要函数的使用1、 lapply()lapply(列表/其他的也会自动转换为列表，循环要处理的函数名，上一个函数所需的参数) 总是返回一个列表 sapply表示在能精简的情况下，尽可能精简处理结果 结果列表元素长度均为1，返回向量 结果列表元素长度相同且大于1，返回矩阵 mean求平均值 2、apply 沿着数组的某一维度处理数据 apply(数组，维度，函数名) 3、tapply 对向量的子集进行操作 tapply (向量，因子/因子列表，函数/函数名) 4、split 根据因子或者因子列表将向量或其他对象分组 通常与lapply一起使用 split(向量/列表/数据框，因子/因子列表) 四、R的绘图系统1)基本绘图系统绘图函数（graphics包） plot/hist/boxplot/pionts/lines/text/title/axis 调用函数会启用一个图形设备（如果没有正在运行的图形设备）并在设备上绘图 基本绘图系统+屏幕设备 plot() 重要参数： xlab/ylab 表示x，y坐标轴标签 lwd 线宽 lty 线的类型 pch 点的类型 col 图形的颜色 par () 用于设置全局参数(作用于R中的所有plot绘图) bg 背景色 mar 边界边距 mfrow 当前画板划分为几行 mfcol 划分为几列 2）Lattice绘图系统1.绘图函数​ lattice包 + xyplot 散点图函数 + histogram 柱状图函数 + dotplot 点图 + contourplot 格式：xyplot(y~x|f*g,data) panel函数，用于控制每个面板内的绘图 grid包 实现了独立于base的绘图系统 lattice包是基于grid创建的 3）Lattice与Base的重要区别​ Base绘图函数直接在图形设备上绘图 ​ Lattice绘图函数返回trellis类对象 ​ 打印函数真正执行了在设备上绘图 4）ggplot2绘图系统 绘图函数 ​ qplot() 类似与Base系统的plot()，参数包含aesthetics/geom/facet… ggplot() 123456789101112131415161718library(ggplot2)qplot(Wind,Temp,data=airquality,color=Month,shape=Month,size=Month ,xlab="Wind(mph)",ylab="Temperature",main="Wind vs. Temp")qplot(Wind,Temp,data=airquality,color=Month,geom=c("point","smooth"))#设置面板属性 ~. Month 表示按月份划分行，1列qplot(Wind,Temp,data=airquality,facets = Month ~.)qplot(Wind,data = airquality,facets = .~ Month)#累加柱状图qplot(Wind,data = airquality,fill=Month)#密度函数qplot(Wind,data = airquality,geom="density",color=Month)qplot(Wind,data = airquality,geom="dotplot",color=Month) 12 图形参数： 符号和线条：pch、cex、lty、lwd 颜色：col、col.axis、col.lab、col.main、col.sub、fg、bg 文本属性：cex、cex.axis、cex.lab、cex.main、cex.sub、font、font.axis、font.lab、font.main、font.sub 文本添加、坐标轴的自定义和图例 title()、main、sub、xlab、ylab、text() axis()、abline() legend() 多图绘制时候，可使用par()设置默认的图形参数 par(lwd=2, cex=1.5) 图形参数设置： par(optionname=value,…) par(pin=c(width,height)) 图形尺寸 par(mfrow=c(nr,nc)) 图形组合，一页多图 layout(mat) 图形组合，一页多图 par(mar=c(bottom,left,top,right)) 边界尺寸 par(fig=c(x1,x2,y1,y2),new=TURE) 多图叠加或排布成一幅图 R语言绘图颜色RColorBrewer包 三类调色板：sequential（渐变）/diverging（极端） /qualitative（分类变量） 参考学习博文链接： R语言入门]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MultiThread]]></title>
    <url>%2F2019%2F06%2F03%2FmultiThread%2F</url>
    <content type="text"><![CDATA[多线程 线程的状态： 一个线程的生命周期： 多线程相关思维导图： Thread 方法：下表列出了Thread类的一些重要方法： 序号 方法描述 1 public void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 2 public void run() 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 public final void setName(String name) 改变线程名称，使之与参数 name 相同。 4 public final void setPriority(int priority) 更改线程的优先级。 5 public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。 6 public final void join(long millisec) 等待该线程终止的时间最长为 millis 毫秒。 7 public void interrupt() 中断线程。 8 public final boolean isAlive() 测试线程是否处于活动状态。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>multiThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F05%2F30%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC (Java DataBase Connection) 是通过JAVA访问数据库 一、MySQL基本 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 使用mysql-front管理数据库 mysql front下载地址 MySQL操作 1、创建与删除数据库 create/drop database dbName 2、创建表1234567CREATE TABLE hero ( id int(11) AUTO_INCREMENT, name varchar(30) , hp float , damage int(11) , PRIMARY KEY (id)) DEFAULT CHARSET=utf8; 3、插入数据insert into hero values (null, &#39;盖伦&#39;, 616, 100) 4、查询数据 查询所有数据 select * from hero 统计表中总共有多少数据 select count(*) from hero 分页查询 select * from hero limit 0,5 5、修改数据修改主键为1的数据 update hero set hp = 818 where id = 1 同理删除 delete hero set hp = 818 where id = 1 WHERE 子句类似于程序语言中的if条件，根据 MySQL 表中的字段值来读取指定的数据。 如果我们想再MySQL数据表中读取指定的数据，WHERE 子句是非常有用的。 使用主键来作为 WHERE 子句的条件查询是非常快速的。 如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。 二、JDBC1、导入mysql-jdbc的jar包（一般会放在新建的lib文件夹中）2、初始化驱动12345678910 try &#123; //驱动类com.mysql.jdbc.Driver //就在 mysql-connector-java-5.0.8-bin.jar中 //如果忘记了第一个步骤的导包，就会抛出ClassNotFoundException Class.forName("com.mysql.jdbc.Driver");System.out.println("数据库驱动加载成功 ！"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 3、建立与数据库连接1Connection c = DriverManager.getConnection("jdbc:mysql://127.0.0.1（本机ip地址，数据库ip）:3306（mysql专用端口号）/数据库名?characterEncoding=UTF-8"（字符集）,"root"（账号名）, "admin"); 4、创建Satement/PreSatement Statement s = c.createStatement(); 引入包为java.sql.Satement PreSatementString sql = “insert into hero values(null,?,?,?)”; // 根据sql语句创建PreparedStatement PreparedStatement ps = c.prepareStatement(sql); // 设置参数 ps.setString(1, “提莫”); ps.setFloat(2, 313.0f); ps.setInt(3, 50); // 执行 ps.execute(); excuteUpdate与excute区别不同1：execute可以执行查询语句然后通过getResultSet，把结果集取出来executeUpdate不能执行查询语句 不同2:execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等executeUpdate返回的是int，表示有多少条数据受到了影响 PreparedStatement优点 PreparedStatement有预编译机制，性能比Statement更快 防止SQL注入式入侵 e.g. select * from hero where name = ‘盖伦’ OR 1=1 因为有OR 1=1，这是恒成立的,就会把这个表里的数据全部查出来,响应变得极其缓慢 使用参数设置，可读性好，不易犯错 5、执行SQL语句CRUD是最常见的数据库操作，即增删改查C 增加(Create)R 读取查询(Retrieve)U 更新(Update)D 删除(Delete) 1)插入 String timo=”提莫” String sql =String.format( “insert into hero values(null,’%s’,313.0,50)”,timo); s.execute(sql); //执行sql语句 2）读取查询12345678ResultSet rs = s.executeQuery(sql);while (rs.next()) &#123; int id = rs.getInt("id");// 可以使用字段名 String name = rs.getString(2);// 也可以使用字段的顺序 float hp = rs.getFloat("hp"); int damage = rs.getInt(4); System.out.printf("%d\t%s\t%f\t%d%n", id, name, hp, damage); &#125; 3）更新 String sql = “update hero set name = ‘Tom’ where id =’2’ ‘’; 4)删除 String sql = “delete from hero where id = 5”; 6、关闭连接先关闭Satement，后关闭Connection 不过一般都是将其放在try（）中，因为它们都实现了AutoCloseable接口 DAODAO=DataAccess Object 数据访问对象，将数据库相关的操作都封装在类中 步骤1.DAO接口1234567891011121314151617181920package jdbc;import java.util.List;import charactor.Hero;public interface DAO&#123; //增加 public void add(Hero hero); //修改 public void update(Hero hero); //删除 public void delete(int id); //获取 public Hero get(int id); //查询 public List&lt;Hero&gt; list(); //分页查询 public List&lt;Hero&gt; list(int start, int count);&#125; 2.设计Hero类实现DAO接口将不同的操作都封装在不同的函数中 数据库连接池原理： 连接池在使用之前，就会创建好一定数量的连接。如果有线程需要连接，可以从连接池中借用，使用完毕后，线程就会把这个连接还给连接池。 倘若发生多线程并发情况，连接池里的连接被借用光了，那么其他线程就会临时等待，直到有连接被归还回来，再继续使用。整个过程，这些连接都不会被关闭，而是不断的被循环使用这样就节省了启动和关闭连接的时间。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket]]></title>
    <url>%2F2019%2F05%2F30%2FSocket%2F</url>
    <content type="text"><![CDATA[网络编程网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。 java.net包中提供了低层次的通信细节。 两种常用的网络协议： TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。 UDP：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。 Socket编程套接字（Socket）使用TCP提供了两台计算机之间的通信机制。 建立TCP连接的步骤： 服务器实例化一个ServerSocket对象，表示通过服务器上的端口通信 服务器调用ServerSocket类的accept()方法，该方法一直等待，直到客户端连接到服务器上给定的端口。 服务器在等待的时候，客户端实例化一个Socket对象，指定服务器名称和端口号来请求连接 Socket类的构造函数试图将客户端连接到指定服务器和端口号。如果通信被建立，则在客户端创建一个Socket对象能够与服务器端进行通信。 在服务器端，accept()方法返回服务器上一个新的Socket引用，给Socket连接到客户端的Socket。 Socket服务端实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package socket;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class Server extends Thread &#123;private ServerSocket serverSocket;//传入端口号 public Server(int port) throws IOException &#123; serverSocket = new ServerSocket(port); &#125; //重写run方法 public void run() &#123; while(true) &#123; System.out.println("等待远程连接，端口号为："+serverSocket.getLocalPort()+"......"); try &#123; //在指定端口号监听，看是否有连接请求过来 Socket server =serverSocket.accept(); System.out.println("远程主机地址：" + server.getRemoteSocketAddress()); //使用数据流对字节流进行封装 DataInputStream in = new DataInputStream(server.getInputStream()); System.out.println(in.readUTF()); //使用Scanner读取控制台的输入，并发送到服务端 DataOutputStream out = new DataOutputStream(server.getOutputStream()); Scanner sc = new Scanner(System.in); String str = sc.next(); out.writeUTF(str); //关闭 server.close(); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; &#125;public static void main(String[] args) &#123; // TODO 自动生成的方法存根 Thread t; try &#123; t = new Server(8000); t.run(); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125;&#125; Socket客户端实例12345678910111213141516171819202122232425262728293031323334353637package socket;import java.net.*;import java.util.Scanner;import java.io.*;public class Client &#123; public static void main(String[] args) &#123; String ServerName; int port; Scanner sc=new Scanner(System.in); System.out.println("请输入你要连接的服务端IP："); ServerName=sc.next(); System.out.println("请输入你要连接的端口号："); port=sc.nextInt(); try &#123; Socket client=new Socket(ServerName,port); OutputStream outToServer = client.getOutputStream(); DataOutputStream out = new DataOutputStream(outToServer); String str; str=sc.next(); out.writeUTF(str); InputStream inFromServer = client.getInputStream(); DataInputStream in = new DataInputStream(inFromServer); System.out.println("服务器响应： " + in.readUTF()); client.close(); &#125; catch (UnknownHostException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125;&#125;&#125; InetAddress 类的方法这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法： 序号 方法描述 1 static InetAddress getByAddress(byte[] addr) 在给定原始 IP 地址的情况下，返回 InetAddress 对象。 2 static InetAddress getByAddress(String host, byte[] addr) 根据提供的主机名和 IP 地址创建 InetAddress。 3 static InetAddress getByName(String host) 在给定主机名的情况下确定主机的 IP 地址。 4 String getHostAddress() 返回 IP 地址字符串（以文本表现形式）。 5 String getHostName() 获取此 IP 地址的主机名。 6 static InetAddress getLocalHost() 返回本地主机。 7 String toString() 将此 IP 地址转换为 String。 Socket类的方法Socket 类有五个构造方法. 序号 方法描述 1 public Socket(String host, int port) throws UnknownHostException, IOException. 创建一个流套接字并将其连接到指定主机上的指定端口号。 2 public Socket(InetAddress host, int port) throws IOException 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 3 public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException. 创建一个套接字并将其连接到指定远程主机上的指定远程端口。 4 public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException. 创建一个套接字并将其连接到指定远程地址上的指定远程端口。 5 public Socket() 通过系统默认类型的 SocketImpl 创建未连接套接字 Socket类其他常用方法： 序号 方法描述 1 public void connect(SocketAddress host, int timeout) throws IOException 将此套接字连接到服务器，并指定一个超时值。 2 public InetAddress getInetAddress() 返回套接字连接的地址。 3 public int getPort() 返回此套接字连接到的远程端口。 4 public int getLocalPort() 返回此套接字绑定到的本地端口。 5 public SocketAddress getRemoteSocketAddress() 返回此套接字连接的端点的地址，如果未连接则返回 null。 6 public InputStream getInputStream() throws IOException 返回此套接字的输入流。 7 public OutputStream getOutputStream() throws IOException 返回此套接字的输出流。 8 public void close() throws IOException 关闭此套接字。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO]]></title>
    <url>%2F2019%2F05%2F26%2FIO%2F</url>
    <content type="text"><![CDATA[I/O]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections]]></title>
    <url>%2F2019%2F05%2F26%2Fcollections%2F</url>
    <content type="text"><![CDATA[集合框架思维导图 Java集合框架概览 三种基本集合框架：1、List（有序、可重复）List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 2、Set（无序、不能重复）Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 3、Map（键值对、键唯一、值不唯一）Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 区别：Vector和ArrayList1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。 arraylist和linkedlist1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 HashMap与TreeMap1、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。2、在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。两个map中的元素一样，但顺序不一样，导致hashCode()不一样。同样做测试：在HashMap中，同样的值的map,顺序不同，equals时，false;而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。 HashTable与HashMap1、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。2、HashMap允许存在一个为null的key，多个为null的value 。3、hashtable的key和value都不允许为null。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>collections</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2019%2F05%2F22%2FMarkDown%2F</url>
    <content type="text"><![CDATA[Markdown使用 使用工具为Typora(其实MP2和sublime3也可以，但没快捷键操作) （1）标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 （2）粗体、斜体、删除线和下划线Markdown 语法： 1234*斜体***粗体*****加粗斜体***~~删除线~~ Typora 快捷键： Ctrl+I：斜体 Ctrl+B：粗体 Ctrl+U：下划线 Alt+Shift+5：删除线 （3）引用块Markdown 语法：&gt; 文字引用 Typora 快捷键： Ctrl+Shift+Q （4）代码块Markdown 语法： 行内代码 12多行代码多行代码 Typora 快捷键： 行内代码：Ctrl+Shift+` 多行代码：Ctrl+Shift+K （5）公式块Markdown 语法： 123$$数学公式$$ Typora 快捷键： Ctrl+Shift+M （6）分割线Markdown 语法： 12345方法一：---方法二：+++方法三：*** （7）列表Markdown 语法： 12345671.有序列表项* 无序列表项+ 无序列表项- 无序列表项 Typora 快捷键： 有序列表项：Ctrl+Shift+[ 无序列表项：Ctrl+Shift+] （8）表格Markdown 语法： 1234表头1|表头2-|-|-内容11|内容12内容21|内容22 e.g ID name 01 Tom 02 Jack Typora 快捷键： Ctrl+T （9）超链接Markdown语法： 12345678方法一：[链接文字](链接地址 &quot;链接描述&quot;)例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)方法二：&lt;链接地址&gt;例如：&lt;https://www.example.com/&gt;方法三：[链接文字]（标记） 标记=url Typora快捷键： Ctrl+K （10）图片Markdown语法： 12![图片文字](图片地址 &quot;图片描述&quot;)例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;) Typora快捷键： Ctrl+Shift+I e.g: 说明：在 Hexo中 插入图片时，请按照以下的步骤进行设置 将 站点配置文件 中的 post_asset_folde 选项的值设置为 true 在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件 这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 ![示例图片](title/example.PNG &quot;示例图片&quot;) 添加图片 发布博客在站点文件夹中打开 git bash，输入如下命令创建文章，其中 title 为文章的标题 1$ hexo new &quot;title&quot; 当输入命令后，就会在 source/_post 文件夹下创建一个文件，命名为：title.md 在站点文件夹中打开 git bash，输入如下命令部署和发布文章 1$ hexo g -d 1建议：在使用 hexo g 部署之后，可以先使用 hexo s 运行本地站点，然后在浏览器输入地址 http://lacolhost:4000/ 查看运行结果，检查无误后再使用 hexo d 发布 此文参考：Hexo系列（五）撰写文章 这个只是用来对于写博客的一个备忘]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
